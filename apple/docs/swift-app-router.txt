Directory Structure:

‚îî‚îÄ‚îÄ ./
    ‚îú‚îÄ‚îÄ Examples
    ‚îÇ   ‚îú‚îÄ‚îÄ AppRouter.swift
    ‚îÇ   ‚îî‚îÄ‚îÄ URLRoutingExample.swift
    ‚îú‚îÄ‚îÄ Sources
    ‚îÇ   ‚îî‚îÄ‚îÄ AppRouter
    ‚îÇ       ‚îú‚îÄ‚îÄ Extensions.swift
    ‚îÇ       ‚îú‚îÄ‚îÄ Protocols.swift
    ‚îÇ       ‚îú‚îÄ‚îÄ Router.swift
    ‚îÇ       ‚îú‚îÄ‚îÄ SimpleRouter.swift
    ‚îÇ       ‚îî‚îÄ‚îÄ URLNavigationHelper.swift
    ‚îú‚îÄ‚îÄ Tests
    ‚îÇ   ‚îî‚îÄ‚îÄ AppRouterTests
    ‚îÇ       ‚îú‚îÄ‚îÄ AppRouterTests.swift
    ‚îÇ       ‚îî‚îÄ‚îÄ SimpleRouterTests.swift
    ‚îú‚îÄ‚îÄ CLAUDE.md
    ‚îú‚îÄ‚îÄ Package.swift
    ‚îî‚îÄ‚îÄ README.md



---
File: /Examples/AppRouter.swift
---

/// AppRouter - A generic tab-based navigation router for SwiftUI
///
/// This library provides a reusable navigation state management solution for SwiftUI apps
/// that use tab-based navigation with navigation stacks and sheet presentation.
///
/// ## Key Features
/// - Generic tab system that works with any tab type
/// - Per-tab navigation stacks
/// - Sheet presentation management
/// - SwiftUI @Observable integration
/// - Thread-safe @MainActor implementation
///
/// ## Usage
///
/// 1. Define your tab type conforming to `TabType`:
/// ```swift
/// enum AppTab: String, TabType, CaseIterable {
///     case home, profile, settings
///
///     var id: String { rawValue }
///     var icon: String {
///         switch self {
///         case .home: return "house"
///         case .profile: return "person"
///         case .settings: return "gear"
///         }
///     }
/// }
/// ```
///
/// 2. Define your destination and sheet types:
/// ```swift
/// enum Destination: DestinationType {
///     case detail(String)
///     case list
/// }
///
/// enum Sheet: SheetType {
///     case settings
///     case profile
///     var id: Int { hashValue }
/// }
/// ```
///
/// 3. Create a type alias for cleaner syntax:
/// ```swift
/// typealias AppRouter = Router<AppTab, Destination, Sheet>
/// ```
///
/// 4. Create and use the router:
/// ```swift
/// @State private var router = AppRouter(initialTab: .home)
///
/// var body: some View {
///     TabView(selection: $router.selectedTab) {
///         ForEach(AppTab.allCases) { tab in
///             NavigationStack(path: $router[tab]) {
///                 ContentView()
///             }
///             .tabItem {
///                 Label(tab.rawValue, systemImage: tab.icon)
///             }
///             .tag(tab)
///         }
///     }
///     .sheet(item: $router.presentedSheet) { sheet in
///         SheetView(sheet: sheet)
///     }
///     .environment(router)
/// }
/// ```
///
/// 5. Use the router in child views:
/// ```swift
/// struct ContentView: View {
///     @Environment(AppRouter.self) private var router
///
///     var body: some View {
///         Button("Navigate") {
///             router.navigateTo(.detail("example"))
///         }
///     }
/// }
/// ```



---
File: /Examples/URLRoutingExample.swift
---

import AppRouter
import SwiftUI

// MARK: - Example App with URL Deep Linking

@main
struct URLRoutingExampleApp: App {
  var body: some Scene {
    WindowGroup {
      URLRoutingContentView()
    }
  }
}

// MARK: - Destination Types

enum Destination: DestinationType {
  case list
  case detail(id: String)
  case profile(userId: String)
  case settings
  case userDetail(id: String)
  case postDetail(id: String)

  // Required for URL deep linking with full path context
  static func from(path: String, fullPath: [String], parameters: [String: String]) -> Destination? {
    // Find the current path index to get context
    guard let currentIndex = fullPath.firstIndex(of: path) else {
      return nil
    }

    let previousComponent = currentIndex > 0 ? fullPath[currentIndex - 1] : nil

    switch (previousComponent, path) {
    case ("users", "detail"):
      let id = parameters["id"] ?? "unknown"
      return .userDetail(id: id)
    case ("posts", "detail"):
      let id = parameters["id"] ?? "unknown"
      return .postDetail(id: id)
    case (_, "list"):
      return .list
    case (_, "detail"):
      let id = parameters["id"] ?? "unknown"
      return .detail(id: id)
    case (_, "profile"):
      let userId = parameters["userId"] ?? "guest"
      return .profile(userId: userId)
    case (_, "settings"):
      return .settings
    case (nil, "users"), (nil, "posts"):
      return nil  // These are just path segments, not destinations
    default:
      return nil
    }
  }
}

enum Sheet: SheetType {
  case compose
  case help

  var id: Int { hashValue }
}

// MARK: - Main Content View

struct URLRoutingContentView: View {
  @State private var router = SimpleRouter<Destination, Sheet>()

  var body: some View {
    NavigationStack(path: $router.path) {
      HomeView()
        .navigationDestination(for: Destination.self) { destination in
          destinationView(for: destination)
        }
        .navigationTitle("URL Routing Demo")
    }
    .sheet(item: $router.presentedSheet) { sheet in
      sheetView(for: sheet)
    }
    .environment(router)
    .onOpenURL { url in
      // This is the key integration with SwiftUI's URL handling
      print("üì± Received URL: \(url)")
      let success = router.navigate(to: url)
      print(success ? "‚úÖ Navigation successful" : "‚ùå Navigation failed")
    }
  }

  @ViewBuilder
  private func destinationView(for destination: Destination) -> some View {
    switch destination {
    case .list:
      ListView()
    case .detail(let id):
      DetailView(id: id)
    case .profile(let userId):
      ProfileView(userId: userId)
    case .settings:
      SettingsView()
    case .userDetail(let id):
      UserDetailView(id: id)
    case .postDetail(let id):
      PostDetailView(id: id)
    }
  }

  @ViewBuilder
  private func sheetView(for sheet: Sheet) -> some View {
    NavigationStack {
      switch sheet {
      case .compose:
        ComposeView()
      case .help:
        HelpView()
      }
    }
  }
}

// MARK: - Views

struct HomeView: View {
  @Environment(SimpleRouter<Destination, Sheet>.self) private var router

  var body: some View {
    VStack(spacing: 20) {
      Text("üîó URL Deep Linking Demo")
        .font(.largeTitle)
        .multilineTextAlignment(.center)

      Text("Try these deep links:")
        .font(.headline)

      VStack(alignment: .leading, spacing: 12) {
        DeepLinkButton(
          title: "List View",
          url: "myapp://list",
          router: router
        )

        DeepLinkButton(
          title: "Detail with ID",
          url: "myapp://detail?id=123",
          router: router
        )

        DeepLinkButton(
          title: "User Profile",
          url: "myapp://profile?userId=john",
          router: router
        )

        DeepLinkButton(
          title: "Navigation Stack",
          url: "myapp://list/detail?id=456",
          router: router
        )

        DeepLinkButton(
          title: "Settings",
          url: "myapp://settings",
          router: router
        )

        DeepLinkButton(
          title: "User Detail (Contextual)",
          url: "myapp://users/detail?id=user123",
          router: router
        )

        DeepLinkButton(
          title: "Post Detail (Contextual)",
          url: "myapp://posts/detail?id=post456",
          router: router
        )
      }

      Divider()

      Text("üìã Current Navigation Path:")
        .font(.headline)

      if router.path.isEmpty {
        Text("Root")
          .foregroundColor(.secondary)
      } else {
        ForEach(Array(router.path.enumerated()), id: \.offset) { index, destination in
          HStack {
            Text("\(index + 1).")
            Text("\(String(describing: destination))")
            Spacer()
          }
          .padding(.horizontal)
          .padding(.vertical, 4)
          .background(Color.blue.opacity(0.1))
          .cornerRadius(8)
        }
      }

      Spacer()

      VStack(spacing: 8) {
        Button("üóÇ Show Compose Sheet") {
          router.presentSheet(.compose)
        }
        .buttonStyle(.borderedProminent)

        if !router.path.isEmpty {
          Button("‚Ü©Ô∏è Pop Navigation") {
            router.popNavigation()
          }
          .buttonStyle(.bordered)

          Button("üè† Pop to Root") {
            router.popToRoot()
          }
          .buttonStyle(.bordered)
        }
      }
    }
    .padding()
  }
}

struct DeepLinkButton: View {
  let title: String
  let url: String
  let router: SimpleRouter<Destination, Sheet>

  var body: some View {
    VStack(alignment: .leading, spacing: 4) {
      Button(title) {
        router.navigate(to: url)
      }
      .buttonStyle(.bordered)

      Text(url)
        .font(.caption)
        .foregroundColor(.secondary)
        .padding(.leading, 16)
    }
  }
}

struct ListView: View {
  @Environment(SimpleRouter<Destination, Sheet>.self) private var router

  var body: some View {
    List {
      ForEach(1...10, id: \.self) { index in
        Button("Item \(index)") {
          router.navigateTo(.detail(id: "item-\(index)"))
        }
      }
    }
    .navigationTitle("List")
    .navigationBarTitleDisplayMode(.large)
  }
}

struct DetailView: View {
  let id: String
  @Environment(SimpleRouter<Destination, Sheet>.self) private var router

  var body: some View {
    VStack(spacing: 20) {
      Text("üìÑ Detail View")
        .font(.largeTitle)

      Text("ID: \(id)")
        .font(.title2)
        .padding()
        .background(Color.blue.opacity(0.1))
        .cornerRadius(8)

      Button("Go to Settings") {
        router.navigateTo(.settings)
      }
      .buttonStyle(.borderedProminent)

      Button("View Profile") {
        router.navigateTo(.profile(userId: "user-from-detail"))
      }
      .buttonStyle(.bordered)

      Spacer()
    }
    .padding()
    .navigationTitle("Detail")
  }
}

struct ProfileView: View {
  let userId: String

  var body: some View {
    VStack(spacing: 20) {
      Text("üë§ Profile View")
        .font(.largeTitle)

      Text("User ID: \(userId)")
        .font(.title2)
        .padding()
        .background(Color.green.opacity(0.1))
        .cornerRadius(8)

      Image(systemName: "person.circle.fill")
        .font(.system(size: 80))
        .foregroundColor(.blue)

      Text("Welcome, \(userId)!")
        .font(.headline)

      Spacer()
    }
    .padding()
    .navigationTitle("Profile")
  }
}

struct SettingsView: View {
  var body: some View {
    Form {
      Section("App Settings") {
        HStack {
          Text("Notifications")
          Spacer()
          Toggle("", isOn: .constant(true))
        }

        HStack {
          Text("Dark Mode")
          Spacer()
          Toggle("", isOn: .constant(false))
        }
      }

      Section("About") {
        Text("URL Routing Demo v1.0")
        Text("Built with AppRouter")
      }
    }
    .navigationTitle("Settings")
  }
}

struct ComposeView: View {
  @Environment(\.dismiss) private var dismiss

  var body: some View {
    VStack(spacing: 20) {
      Text("‚úçÔ∏è Compose")
        .font(.largeTitle)

      TextEditor(text: .constant("Write something..."))
        .border(Color.gray, width: 1)
        .frame(height: 200)

      Button("Done") {
        dismiss()
      }
      .buttonStyle(.borderedProminent)

      Spacer()
    }
    .padding()
    .navigationTitle("Compose")
    .navigationBarTitleDisplayMode(.inline)
    .toolbar {
      ToolbarItem(placement: .navigationBarLeading) {
        Button("Cancel") {
          dismiss()
        }
      }
    }
  }
}

struct HelpView: View {
  var body: some View {
    VStack {
      Text("Help")
        .font(.largeTitle)

      Text("This is a help view")

      Spacer()
    }
    .padding()
  }
}

struct UserDetailView: View {
  let id: String

  var body: some View {
    VStack(spacing: 20) {
      Text("üë§ User Detail")
        .font(.largeTitle)

      Text("User ID: \(id)")
        .font(.title2)
        .padding()
        .background(Color.blue.opacity(0.1))
        .cornerRadius(8)

      Image(systemName: "person.circle")
        .font(.system(size: 60))
        .foregroundColor(.blue)

      Text("This is a specific user detail view, different from a generic detail view")
        .multilineTextAlignment(.center)
        .foregroundColor(.secondary)

      Spacer()
    }
    .padding()
    .navigationTitle("User Details")
  }
}

struct PostDetailView: View {
  let id: String

  var body: some View {
    VStack(spacing: 20) {
      Text("üìù Post Detail")
        .font(.largeTitle)

      Text("Post ID: \(id)")
        .font(.title2)
        .padding()
        .background(Color.green.opacity(0.1))
        .cornerRadius(8)

      Image(systemName: "doc.text")
        .font(.system(size: 60))
        .foregroundColor(.green)

      Text("This is a specific post detail view, different from a generic detail view")
        .multilineTextAlignment(.center)
        .foregroundColor(.secondary)

      Spacer()
    }
    .padding()
    .navigationTitle("Post Details")
  }
}

// MARK: - URL Scheme Configuration

/*
 Add this to your Info.plist to handle the "myapp://" URL scheme:

 <key>CFBundleURLTypes</key>
 <array>
     <dict>
         <key>CFBundleURLName</key>
         <string>myapp.deeplink</string>
         <key>CFBundleURLSchemes</key>
         <array>
             <string>myapp</string>
         </array>
     </dict>
 </array>

 Test URLs in iOS Simulator:
 xcrun simctl openurl booted "myapp://list"
 xcrun simctl openurl booted "myapp://detail?id=test123"
 xcrun simctl openurl booted "myapp://profile?userId=alice"
 xcrun simctl openurl booted "myapp://list/detail?id=deep-link"
 xcrun simctl openurl booted "myapp://users/detail?id=user123"
 xcrun simctl openurl booted "myapp://posts/detail?id=post456"
 */



---
File: /Sources/AppRouter/Extensions.swift
---

import Foundation
import SwiftUI

// MARK: - Environment Extensions

extension EnvironmentValues {
  /// The currently active tab in the environment
  @Entry public var currentTab: (any TabType)? = nil
}

// MARK: - URL Extensions

extension URL {
  /// Creates a URL for deep linking with the specified destinations
  /// - Parameters:
  ///   - scheme: The URL scheme (e.g., "myapp")
  ///   - destinations: Array of destinations to navigate through
  ///   - parameters: Query parameters to include
  /// - Returns: A URL for deep linking, or nil if construction fails
  public static func deepLink<Destination: DestinationType>(
    scheme: String,
    destinations: [Destination],
    parameters: [String: String] = [:]
  ) -> URL? {
    guard !destinations.isEmpty else { return nil }

    var components = URLComponents()
    components.scheme = scheme

    // Use host for the first destination
    components.host = String(describing: destinations.first!)

    // Add remaining destinations as path if they exist
    if destinations.count > 1 {
      components.path =
        "/" + destinations.dropFirst().map { String(describing: $0) }.joined(separator: "/")
    }

    if !parameters.isEmpty {
      components.queryItems = parameters.map { URLQueryItem(name: $0.key, value: $0.value) }
    }

    return components.url
  }
}



---
File: /Sources/AppRouter/Protocols.swift
---

import SwiftUI

/// A type that can serve as a navigation destination.
public protocol DestinationType: Hashable {
  /// Creates a destination from a URL path component with full path context and query parameters
  /// - Parameters:
  ///   - path: The current URL path component
  ///   - fullPath: The complete array of path components for context
  ///   - parameters: Query parameters from the URL
  /// - Returns: A destination instance if the path matches, nil otherwise
  static func from(path: String, fullPath: [String], parameters: [String: String]) -> Self?
}

/// A type that can be presented as a sheet.
public protocol SheetType: Hashable, Identifiable {}

/// A type that can serve as a tab in a tab-based navigation system.
/// Only needed when using the full Router<Tab, Destination, Sheet> for tab-based navigation.
public protocol TabType: Hashable, CaseIterable, Identifiable, Sendable {
  /// The icon name (SF Symbol) for this tab
  var icon: String { get }
}



---
File: /Sources/AppRouter/Router.swift
---

import Foundation
import SwiftUI

/// A generic navigation router that manages tab-based navigation state with navigation stacks and sheet presentation.
@Observable
@MainActor
public final class Router<Tab: TabType, Destination: DestinationType, Sheet: SheetType> {

  // MARK: - Private Properties

  /// Navigation paths for each tab
  private var paths: [Tab: [Destination]] = [:]

  // MARK: - Public Properties

  /// The currently selected tab
  public var selectedTab: Tab

  /// The currently presented sheet, if any
  public var presentedSheet: Sheet?

  // MARK: - Initialization

  /// Creates a new router with the specified initial tab.
  /// - Parameter initialTab: The tab to select when the router is created
  public init(initialTab: Tab) {
    self.selectedTab = initialTab
  }

  // MARK: - Path Access

  /// Subscript access to navigation paths for each tab
  public subscript(tab: Tab) -> [Destination] {
    get { paths[tab] ?? [] }
    set { paths[tab] = newValue }
  }

  /// The navigation path for the currently selected tab
  public var selectedTabPath: [Destination] {
    paths[selectedTab] ?? []
  }

  // MARK: - Navigation Methods

  /// Pops the navigation stack to the root for the specified tab (or current tab if nil).
  /// - Parameter tab: The tab to pop to root. If nil, uses the currently selected tab.
  public func popToRoot(for tab: Tab? = nil) {
    paths[tab ?? selectedTab] = []
  }

  /// Pops the last destination from the navigation stack for the specified tab.
  /// - Parameter tab: The tab to pop from. If nil, uses the currently selected tab.
  public func popNavigation(for tab: Tab? = nil) {
    let targetTab = tab ?? selectedTab
    if paths[targetTab]?.isEmpty == false {
      paths[targetTab]?.removeLast()
    }
  }

  /// Navigates to the specified destination for the specified tab.
  /// - Parameters:
  ///   - destination: The destination to navigate to
  ///   - tab: The tab to navigate in. If nil, uses the currently selected tab.
  public func navigateTo(_ destination: Destination, for tab: Tab? = nil) {
    let targetTab = tab ?? selectedTab
    if paths[targetTab] == nil {
      paths[targetTab] = [destination]
    } else {
      paths[targetTab]?.append(destination)
    }
  }

  // MARK: - Sheet Methods

  /// Presents the specified sheet.
  /// - Parameter sheet: The sheet to present
  public func presentSheet(_ sheet: Sheet) {
    presentedSheet = sheet
  }

  /// Dismisses the currently presented sheet.
  public func dismissSheet() {
    presentedSheet = nil
  }

  // MARK: - URL Routing Methods

  /// Navigates to a URL by parsing its components and routing accordingly
  /// - Parameter url: The URL to navigate to
  /// - Returns: True if the URL was successfully routed, false otherwise
  @discardableResult
  public func navigate(to url: URL) -> Bool {
    return URLNavigationHelper.navigate(url: url) { destinations in
      paths[selectedTab] = destinations
    }
  }

  /// Navigates to a URL string by parsing its components and routing accordingly
  /// - Parameter urlString: The URL string to navigate to
  /// - Returns: True if the URL was successfully routed, false otherwise
  @discardableResult
  public func navigate(to urlString: String) -> Bool {
    guard let url = URL(string: urlString) else {
      return false
    }
    return navigate(to: url)
  }
}



---
File: /Sources/AppRouter/SimpleRouter.swift
---

import Foundation
import SwiftUI

/// A simple navigation router for single-stack navigation with sheet presentation.
/// Use this when you don't need tab-based navigation, just a single NavigationStack.
@Observable
@MainActor
public final class SimpleRouter<Destination: DestinationType, Sheet: SheetType> {

  // MARK: - Public Properties

  /// The navigation path for the router
  public var path: [Destination] = []

  /// The currently presented sheet, if any
  public var presentedSheet: Sheet?

  // MARK: - Initialization

  /// Creates a new simple router
  public init() {}

  // MARK: - Navigation Methods

  /// Pops the navigation stack to the root
  public func popToRoot() {
    path = []
  }

  /// Pops the last destination from the navigation stack
  public func popNavigation() {
    if !path.isEmpty {
      path.removeLast()
    }
  }

  /// Navigates to the specified destination
  /// - Parameter destination: The destination to navigate to
  public func navigateTo(_ destination: Destination) {
    path.append(destination)
  }

  // MARK: - Sheet Methods

  /// Presents the specified sheet
  /// - Parameter sheet: The sheet to present
  public func presentSheet(_ sheet: Sheet) {
    presentedSheet = sheet
  }

  /// Dismisses the currently presented sheet
  public func dismissSheet() {
    presentedSheet = nil
  }

  // MARK: - URL Routing Methods

  /// Navigates to a URL by parsing its components and routing accordingly
  /// - Parameter url: The URL to navigate to
  /// - Returns: True if the URL was successfully routed, false otherwise
  @discardableResult
  public func navigate(to url: URL) -> Bool {
    return URLNavigationHelper.navigate(url: url) { destinations in
      path = destinations
    }
  }

  /// Navigates to a URL string by parsing its components and routing accordingly
  /// - Parameter urlString: The URL string to navigate to
  /// - Returns: True if the URL was successfully routed, false otherwise
  @discardableResult
  public func navigate(to urlString: String) -> Bool {
    guard let url = URL(string: urlString) else {
      return false
    }
    return navigate(to: url)
  }
}



---
File: /Sources/AppRouter/URLNavigationHelper.swift
---

import Foundation

/// Helper for shared URL navigation logic
internal enum URLNavigationHelper {
  /// Navigates to a URL by parsing its components and applying destinations
  /// - Parameters:
  ///   - url: The URL to navigate to
  ///   - applyDestinations: Closure that applies the parsed destinations
  /// - Returns: True if navigation was successful, false otherwise
  static func navigate<Destination: DestinationType>(
    url: URL,
    applyDestinations: ([Destination]) -> Void
  ) -> Bool {
    guard let components = URLComponents(url: url, resolvingAgainstBaseURL: false) else {
      return false
    }

    // Extract path components from host and path (e.g., myapp://detail/list)
    var pathComponents: [String] = []

    // Start with host as first component
    if let host = components.host {
      pathComponents.append(host)
    }

    // Add path components if they exist
    if !components.path.isEmpty {
      let pathParts = components.path.split(separator: "/").map(String.init).filter { !$0.isEmpty }
      pathComponents.append(contentsOf: pathParts)
    }

    guard !pathComponents.isEmpty else { return false }

    let queryParameters = parseQueryParameters(from: components.queryItems)

    // Convert path components to destinations
    var destinations: [Destination] = []
    for pathComponent in pathComponents {
      if let destination = Destination.from(
        path: pathComponent, fullPath: pathComponents, parameters: queryParameters)
      {
        destinations.append(destination)
      }
    }

    guard !destinations.isEmpty else { return false }

    applyDestinations(destinations)
    return true
  }

  /// Parses query parameters from URL components
  /// - Parameter queryItems: Array of URLQueryItem from URLComponents
  /// - Returns: Dictionary of query parameters
  private static func parseQueryParameters(from queryItems: [URLQueryItem]?) -> [String: String] {
    guard let queryItems = queryItems else { return [:] }

    var parameters: [String: String] = [:]
    for item in queryItems {
      if let value = item.value {
        parameters[item.name] = value
      }
    }
    return parameters
  }
}



---
File: /Tests/AppRouterTests/AppRouterTests.swift
---

import XCTest

@testable import AppRouter

// Test types
enum TestTab: String, TabType, CaseIterable {
  case home, profile, settings

  var id: String { rawValue }
  var icon: String { "house" }
}

enum TestDestination: DestinationType {
  case detail(String)
  case list
  case userDetail(String)
  case postDetail(String)

  static func from(path: String, fullPath: [String], parameters: [String: String])
    -> TestDestination?
  {
    guard let currentIndex = fullPath.firstIndex(of: path) else {
      return nil
    }

    let previousComponent = currentIndex > 0 ? fullPath[currentIndex - 1] : nil

    switch (previousComponent, path) {
    case ("users", "detail"):
      let id = parameters["id"] ?? "unknown"
      return .userDetail(id)
    case ("posts", "detail"):
      let id = parameters["id"] ?? "unknown"
      return .postDetail(id)
    case (_, "list"):
      return .list
    case (_, "detail"):
      if let id = parameters["id"] {
        return .detail(id)
      }
      return .detail("default")
    case (nil, "users"), (nil, "posts"):
      return nil  // These are just path segments, not destinations
    default:
      return nil
    }
  }
}

enum TestSheet: SheetType {
  case settings
  case profile

  var id: Int { hashValue }
}

@MainActor
final class AppRouterTests: XCTestCase {

  var router: Router<TestTab, TestDestination, TestSheet>!

  override func setUp() {
    super.setUp()
    router = Router(initialTab: .home)
  }

  override func tearDown() {
    router = nil
    super.tearDown()
  }

  func testInitialState() {
    XCTAssertEqual(router.selectedTab, .home)
    XCTAssertNil(router.presentedSheet)
    XCTAssertTrue(router.selectedTabPath.isEmpty)
  }

  func testNavigation() {
    router.navigateTo(.detail("test"))
    XCTAssertEqual(router.selectedTabPath.count, 1)

    router.navigateTo(.list)
    XCTAssertEqual(router.selectedTabPath.count, 2)
  }

  func testPopNavigation() {
    router.navigateTo(.detail("test"))
    router.navigateTo(.list)

    router.popNavigation()
    XCTAssertEqual(router.selectedTabPath.count, 1)

    router.popNavigation()
    XCTAssertTrue(router.selectedTabPath.isEmpty)
  }

  func testPopToRoot() {
    router.navigateTo(.detail("test"))
    router.navigateTo(.list)

    router.popToRoot()
    XCTAssertTrue(router.selectedTabPath.isEmpty)
  }

  func testPerTabNavigation() {
    router.navigateTo(.detail("home"), for: .home)
    router.navigateTo(.list, for: .profile)

    XCTAssertEqual(router[.home].count, 1)
    XCTAssertEqual(router[.profile].count, 1)
    XCTAssertTrue(router[.settings].isEmpty)
  }

  func testSheetPresentation() {
    router.presentSheet(.settings)
    XCTAssertEqual(router.presentedSheet, .settings)

    router.dismissSheet()
    XCTAssertNil(router.presentedSheet)
  }

  func testTabSwitching() {
    router.selectedTab = .profile
    XCTAssertEqual(router.selectedTab, .profile)

    router.navigateTo(.detail("profile"))
    XCTAssertEqual(router.selectedTabPath.count, 1)

    router.selectedTab = .home
    XCTAssertTrue(router.selectedTabPath.isEmpty)
    XCTAssertEqual(router[.profile].count, 1)
  }

  // MARK: - URL Routing Tests

  func testURLNavigationToSingleDestination() {
    let result = router.navigate(to: "myapp://list")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)
    XCTAssertEqual(router.selectedTabPath[0], .list)
  }

  func testURLNavigationToDestinationWithParameters() {
    let result = router.navigate(to: "myapp://detail?id=123")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)

    if case let .detail(id) = router.selectedTabPath.first {
      XCTAssertEqual(id, "123")
    } else {
      XCTFail("Expected detail destination with id")
    }
  }

  func testURLNavigationToMultipleDestinations() {
    let result = router.navigate(to: "myapp://list/detail")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 2)

    XCTAssertEqual(router.selectedTabPath[0], .list)
    if case let .detail(id) = router.selectedTabPath[1] {
      XCTAssertEqual(id, "default")  // Should get default since no parameter
    } else {
      XCTFail("Expected detail destination with id")
    }
  }

  func testURLNavigationWithInvalidDestination() {
    let result = router.navigate(to: "myapp://invalid")
    XCTAssertFalse(result)  // Should fail since no valid destinations
    XCTAssertTrue(router.selectedTabPath.isEmpty)  // No destinations added
  }

  func testURLNavigationWithMalformedURL() {
    let result = router.navigate(to: "not a url")
    XCTAssertFalse(result)
    XCTAssertTrue(router.selectedTabPath.isEmpty)  // Should remain unchanged
  }

  func testURLNavigationWithEmptyHost() {
    let result = router.navigate(to: "myapp://")
    XCTAssertFalse(result)
    XCTAssertTrue(router.selectedTabPath.isEmpty)  // Should remain unchanged
  }

  func testURLNavigationReplacesExistingPath() {
    // Set up existing navigation
    router.navigateTo(.detail("existing"))
    router.navigateTo(.list)
    XCTAssertEqual(router.selectedTabPath.count, 2)

    // Navigate via URL - should replace existing path
    let result = router.navigate(to: "myapp://detail?id=newValue")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)

    if case let .detail(id) = router.selectedTabPath[0] {
      XCTAssertEqual(id, "newValue")
    } else {
      XCTFail("Expected detail destination with new value")
    }
  }

  // MARK: - Contextual URL Routing Tests

  func testContextualUserDetailRoute() {
    let result = router.navigate(to: "myapp://users/detail?id=user123")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)

    if case let .userDetail(id) = router.selectedTabPath[0] {
      XCTAssertEqual(id, "user123")
    } else {
      XCTFail("Expected userDetail destination")
    }
  }

  func testContextualPostDetailRoute() {
    let result = router.navigate(to: "myapp://posts/detail?id=post456")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)

    if case let .postDetail(id) = router.selectedTabPath[0] {
      XCTAssertEqual(id, "post456")
    } else {
      XCTFail("Expected postDetail destination")
    }
  }

  func testContextualRoutingDifferentiatesDetailTypes() {
    // Test that users/detail and posts/detail create different destination types
    let userResult = router.navigate(to: "myapp://users/detail?id=123")
    XCTAssertTrue(userResult)

    if case .userDetail = router.selectedTabPath[0] {
      // Expected
    } else {
      XCTFail("Expected userDetail destination")
    }

    let postResult = router.navigate(to: "myapp://posts/detail?id=123")
    XCTAssertTrue(postResult)

    if case .postDetail = router.selectedTabPath[0] {
      // Expected
    } else {
      XCTFail("Expected postDetail destination")
    }
  }

  func testNonContextualDetailStillWorks() {
    // Test that the original detail route without context still works
    let result = router.navigate(to: "myapp://detail?id=generic")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)

    if case let .detail(id) = router.selectedTabPath[0] {
      XCTAssertEqual(id, "generic")
    } else {
      XCTFail("Expected generic detail destination")
    }
  }

  func testContextualRoutingWithoutParameters() {
    let result = router.navigate(to: "myapp://users/detail")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)

    if case let .userDetail(id) = router.selectedTabPath[0] {
      XCTAssertEqual(id, "unknown")  // Should get default value
    } else {
      XCTFail("Expected userDetail destination with default id")
    }
  }
}



---
File: /Tests/AppRouterTests/SimpleRouterTests.swift
---

import XCTest

@testable import AppRouter

// Test types for SimpleRouter
enum SimpleDestination: DestinationType {
  case detail(String)
  case list
  case settings

  static func from(path: String, fullPath: [String], parameters: [String: String])
    -> SimpleDestination?
  {
    guard fullPath.contains(path) else {
      return nil
    }

    switch path {
    case "list":
      return .list
    case "settings":
      return .settings
    case "detail":
      if let id = parameters["id"] {
        return .detail(id)
      }
      return .detail("default")
    default:
      return nil
    }
  }
}

enum SimpleSheet: SheetType {
  case compose
  case settings

  var id: Int { hashValue }
}

@MainActor
final class SimpleRouterTests: XCTestCase {

  var router: SimpleRouter<SimpleDestination, SimpleSheet>!

  override func setUp() {
    super.setUp()
    router = SimpleRouter()
  }

  override func tearDown() {
    router = nil
    super.tearDown()
  }

  func testInitialState() {
    XCTAssertTrue(router.path.isEmpty)
    XCTAssertNil(router.presentedSheet)
  }

  func testNavigation() {
    router.navigateTo(.detail("test"))
    XCTAssertEqual(router.path.count, 1)

    router.navigateTo(.list)
    XCTAssertEqual(router.path.count, 2)

    router.navigateTo(.settings)
    XCTAssertEqual(router.path.count, 3)
  }

  func testPopNavigation() {
    router.navigateTo(.detail("test"))
    router.navigateTo(.list)
    router.navigateTo(.settings)

    router.popNavigation()
    XCTAssertEqual(router.path.count, 2)

    router.popNavigation()
    XCTAssertEqual(router.path.count, 1)

    router.popNavigation()
    XCTAssertTrue(router.path.isEmpty)

    // Should handle empty path gracefully
    router.popNavigation()
    XCTAssertTrue(router.path.isEmpty)
  }

  func testPopToRoot() {
    router.navigateTo(.detail("test"))
    router.navigateTo(.list)
    router.navigateTo(.settings)

    router.popToRoot()
    XCTAssertTrue(router.path.isEmpty)
  }

  func testSheetPresentation() {
    router.presentSheet(.compose)
    XCTAssertEqual(router.presentedSheet, .compose)

    router.dismissSheet()
    XCTAssertNil(router.presentedSheet)

    router.presentSheet(.settings)
    XCTAssertEqual(router.presentedSheet, .settings)

    // Test replacing current sheet
    router.presentSheet(.compose)
    XCTAssertEqual(router.presentedSheet, .compose)
  }

  func testNavigationAndSheetTogether() {
    // Test that navigation and sheet state are independent
    router.navigateTo(.detail("test"))
    router.presentSheet(.compose)

    XCTAssertEqual(router.path.count, 1)
    XCTAssertEqual(router.presentedSheet, .compose)

    router.popNavigation()
    XCTAssertTrue(router.path.isEmpty)
    XCTAssertEqual(router.presentedSheet, .compose)  // Sheet should remain

    router.dismissSheet()
    XCTAssertNil(router.presentedSheet)
  }

  // MARK: - URL Routing Tests

  func testURLNavigationToSingleDestination() {
    let result = router.navigate(to: "myapp://list")
    XCTAssertTrue(result)
    XCTAssertEqual(router.path.count, 1)
    XCTAssertEqual(router.path[0], .list)
  }

  func testURLNavigationToDestinationWithParameters() {
    let result = router.navigate(to: "myapp://detail?id=test123")
    XCTAssertTrue(result)
    XCTAssertEqual(router.path.count, 1)

    if case let .detail(id) = router.path[0] {
      XCTAssertEqual(id, "test123")
    } else {
      XCTFail("Expected detail destination with id")
    }
  }

  func testURLNavigationToMultipleDestinations() {
    let result = router.navigate(to: "myapp://list/detail/settings?id=456")
    XCTAssertTrue(result)
    XCTAssertEqual(router.path.count, 3)

    XCTAssertEqual(router.path[0], .list)
    if case let .detail(id) = router.path[1] {
      XCTAssertEqual(id, "456")
    } else {
      XCTFail("Expected detail destination with id")
    }
    XCTAssertEqual(router.path[2], .settings)
  }

  func testURLNavigationWithInvalidDestination() {
    let result = router.navigate(to: "myapp://invalid")
    XCTAssertFalse(result)  // Should fail for SimpleRouter since no valid destinations
    XCTAssertTrue(router.path.isEmpty)
  }

  func testURLNavigationWithMalformedURL() {
    let result = router.navigate(to: "not a url")
    XCTAssertFalse(result)
    XCTAssertTrue(router.path.isEmpty)
  }

  func testURLNavigationWithEmptyHost() {
    let result = router.navigate(to: "myapp://")
    XCTAssertFalse(result)
    XCTAssertTrue(router.path.isEmpty)
  }

  func testURLNavigationClearsExistingPath() {
    // Set up existing navigation
    router.navigateTo(.detail("existing"))
    router.navigateTo(.list)
    XCTAssertEqual(router.path.count, 2)

    // Navigate via URL - should replace existing path
    let result = router.navigate(to: "myapp://settings")
    XCTAssertTrue(result)
    XCTAssertEqual(router.path.count, 1)
    XCTAssertEqual(router.path[0], .settings)
  }
}



---
File: /CLAUDE.md
---

# AppRouter - Claude.md

## Project Overview
AppRouter is a SwiftUI navigation router library that provides both simple single-stack navigation (`SimpleRouter`) and complex tab-based navigation (`Router`) with independent navigation stacks and sheet presentation. The library targets iOS 17+, macOS 14+, tvOS 17+, and watchOS 10+ using Swift 5.9+.

## Build & Test Commands
```bash
# Build the package
swift build

# Run tests
swift test

# Build for specific platform
swift build --arch arm64 --target AppRouter

# Test with verbose output
swift test --verbose

# Check for Swift format/lint (if available)
swift-format --configuration .swift-format Sources/ Tests/
```

## Project Structure
- `Sources/AppRouter/` - Main library code
  - `Router.swift` - Tab-based navigation router
  - `SimpleRouter.swift` - Single-stack navigation router  
  - `Protocols.swift` - Core protocols (DestinationType, SheetType, TabType)
  - `Extensions.swift` - URL navigation helpers and extensions
  - `URLNavigationHelper.swift` - Deep linking utilities
- `Tests/AppRouterTests/` - Unit tests
- `Examples/` - Usage examples
- `Package.swift` - Swift Package Manager configuration

## Key Components

### Core Classes
- `Router<Tab, Destination, Sheet>` - Tab-based navigation with independent stacks per tab
- `SimpleRouter<Destination, Sheet>` - Single NavigationStack with sheet support
- Both are `@Observable @MainActor` for SwiftUI integration

### Protocols
- `DestinationType: Hashable` - Navigation destinations with URL parsing support
- `SheetType: Hashable, Identifiable` - Sheet presentations  
- `TabType: Hashable, CaseIterable, Identifiable, Sendable` - Tab definitions

### Navigation Methods
- `navigateTo(_:)` / `navigateTo(_:for:)` - Push destinations
- `popNavigation()` / `popToRoot()` - Pop navigation stack
- `presentSheet(_:)` / `dismissSheet()` - Sheet management
- `navigate(to: URL)` - Deep linking navigation

## Development Guidelines

### Code Style
- Follow Swift API Design Guidelines
- Use `@MainActor` for UI-related classes
- Prefer `@Observable` over `ObservableObject` for iOS 17+
- Use protocol-oriented design for flexibility
- Include comprehensive documentation comments

### Testing
- Unit tests in `Tests/AppRouterTests/`
- Test both `Router` and `SimpleRouter` functionality
- Mock destinations and sheets for testing
- Verify navigation state changes
- Test URL deep linking parsing

### URL Deep Linking
- Implement `DestinationType.from(path:parameters:)` for URL parsing
- URL format: `scheme://destination1/destination2?param1=value1`
- Support navigation through multiple destinations
- Handle URL validation and error cases

### Common Tasks
- Add new navigation methods to both Router classes
- Extend protocols for additional functionality  
- Update Examples/ with new features
- Ensure thread safety with `@MainActor`
- Maintain backwards compatibility within major versions

## Example Usage Patterns

### Simple Router Setup
```swift
@State private var router = SimpleRouter<Destination, Sheet>()

NavigationStack(path: $router.path) {
    // Root view
}.environment(router)
```

### Tab Router Setup  
```swift
@State private var router = Router<AppTab, Destination, Sheet>(initialTab: .home)

TabView(selection: $router.selectedTab) {
    // Tab content with NavigationStack(path: $router[tab])
}.environment(router)
```

### Navigation Usage
```swift
@Environment(AppRouter.self) private var router

router.navigateTo(.detail(id: "123"))
router.presentSheet(.settings)
router.navigate(to: "myapp://detail?id=456")
```

## Dependencies
- No external dependencies
- Uses only SwiftUI and Foundation
- Swift Package Manager for distribution

## Platform Support
- iOS 17.0+
- macOS 14.0+ 
- tvOS 17.0+
- watchOS 10.0+
- Swift 5.9+


---
File: /Package.swift
---

// swift-tools-version: 5.9
import PackageDescription

let package = Package(
    name: "AppRouter",
    platforms: [
        .iOS(.v17),
        .macOS(.v14),
        .tvOS(.v17),
        .watchOS(.v10)
    ],
    products: [
        .library(
            name: "AppRouter",
            targets: ["AppRouter"]),
    ],
    targets: [
        .target(
            name: "AppRouter"),
        .testTarget(
            name: "AppRouterTests",
            dependencies: ["AppRouter"]),
    ]
)


---
File: /README.md
---

# AppRouter

A generic, reusable navigation router for SwiftUI applications. Supports both simple single-stack navigation and complex tab-based navigation with independent navigation stacks and sheet presentation.

## Features

- üéØ **Simple Router** - `SimpleRouter` for single NavigationStack apps
- üè∑Ô∏è **Tab Router** - `Router` for tab-based apps with independent navigation per tab
- üìÑ **Sheet Management** - Built-in sheet presentation and dismissal
- üîÑ **SwiftUI Integration** - Uses `@Observable` for reactive state updates
- üßµ **Thread Safe** - `@MainActor` implementation ensures UI safety
- üì± **iOS 17+ Ready** - Built for modern SwiftUI patterns
- üîó **URL Deep Linking** - Navigate via URLs with automatic parameter parsing
- üõ§Ô∏è **Contextual Routing** - Same path components create different destinations based on context (e.g., `/users/detail` vs `/posts/detail`)

## Installation

### Swift Package Manager

Add this package to your project:

```swift
dependencies: [
    .package(url: "https://github.com/dimillian/AppRouter.git", from: "1.0.0")
]
```

## Quick Start

AppRouter provides two routers depending on your app's navigation needs:

- **`SimpleRouter`** - For apps with a single NavigationStack
- **`Router`** - For apps with tab-based navigation

### Option 1: Simple Navigation (Single Stack)

Perfect for apps that don't use tabs and just need a single navigation stack with sheet support.

```swift
import SwiftUI
import AppRouter

// 1. Define your destination and sheet types
enum Destination: DestinationType {
    case detail(id: String)
    case settings
    case profile(userId: String)
}

enum Sheet: SheetType {
    case compose
    case settings
    
    var id: Int { hashValue }
}

// 2. Use SimpleRouter
struct ContentView: View {
    @State private var router = SimpleRouter<Destination, Sheet>()
    
    var body: some View {
        NavigationStack(path: $router.path) {
            HomeView()
                .navigationDestination(for: Destination.self) { destination in
                    destinationView(for: destination)
                }
        }
        .sheet(item: $router.presentedSheet) { sheet in
            sheetView(for: sheet)
        }
        .environment(router)
    }
    
    @ViewBuilder
    private func destinationView(for destination: Destination) -> some View {
        switch destination {
        case .detail(let id):
            DetailView(id: id)
        case .settings:
            SettingsView()
        case .profile(let userId):
            ProfileView(userId: userId)
        }
    }
    
    @ViewBuilder
    private func sheetView(for sheet: Sheet) -> some View {
        switch sheet {
        case .compose:
            ComposeView()
        case .settings:
            SettingsSheet()
        }
    }
}

// 3. Navigate from anywhere in your app
struct HomeView: View {
    @Environment(SimpleRouter<Destination, Sheet>.self) private var router
    
    var body: some View {
        VStack {
            Button("Go to Detail") {
                router.navigateTo(.detail(id: "123"))
            }
            
            Button("Show Compose Sheet") {
                router.presentSheet(.compose)
            }
        }
    }
}
```

### Option 2: Tab-Based Navigation

For apps that use TabView with independent navigation stacks per tab.

#### 1. Define Your Tab Type

```swift
import AppRouter

enum AppTab: String, TabType, CaseIterable {
    case home, profile, settings
    
    var id: String { rawValue }
    
    var icon: String {
        switch self {
        case .home: return "house"
        case .profile: return "person"  
        case .settings: return "gear"
        }
    }
}
```

#### 2. Define Destination and Sheet Types

```swift
enum Destination: DestinationType {
    case detail(id: String)
    case list
    case profile(userId: String)
}

enum Sheet: SheetType {
    case settings
    case profile
    case compose
    
    var id: Int { hashValue }
}
```

#### 3. Use the Tab Router

```swift
import SwiftUI
import AppRouter

struct ContentView: View {
    @State private var router = Router<AppTab, Destination, Sheet>(initialTab: .home)
    
    var body: some View {
        TabView(selection: $router.selectedTab) {
            ForEach(AppTab.allCases) { tab in
                NavigationStack(path: $router[tab]) {
                    HomeView()
                        .navigationDestination(for: Destination.self) { destination in
                            destinationView(for: destination)
                        }
                }
                .tabItem {
                    Label(tab.rawValue.capitalized, systemImage: tab.icon)
                }
                .tag(tab)
            }
        }
        .sheet(item: $router.presentedSheet) { sheet in
            sheetView(for: sheet)
        }
    }
    
    @ViewBuilder
    private func destinationView(for destination: Destination) -> some View {
        switch destination {
        case .detail(let id):
            DetailView(id: id)
        case .list:
            ListView()
        case .profile(let userId):
            ProfileView(userId: userId)
        }
    }
    
    @ViewBuilder  
    private func sheetView(for sheet: Sheet) -> some View {
        switch sheet {
        case .settings:
            SettingsView()
        case .profile:
            ProfileSheet()
        case .compose:
            ComposeView()
        }
    }
}
```

## API Reference

### SimpleRouter

For single NavigationStack apps:

```swift
@Observable @MainActor
public final class SimpleRouter<Destination: DestinationType, Sheet: SheetType>
```

#### Properties
- `path: [Destination]` - Navigation path
- `presentedSheet: Sheet?` - Currently presented sheet

#### Methods
- `navigateTo(_:)` - Navigate to a destination
- `popNavigation()` - Pop last destination from stack
- `popToRoot()` - Clear navigation stack
- `presentSheet(_:)` - Present a sheet
- `dismissSheet()` - Dismiss current sheet
- `navigate(to:)` - Navigate using a URL or URL string

### Router

For tab-based apps with independent navigation per tab:

```swift
@Observable @MainActor
public final class Router<Tab: TabType, Destination: DestinationType, Sheet: SheetType>
```

#### Properties
- `selectedTab: Tab` - Currently selected tab
- `presentedSheet: Sheet?` - Currently presented sheet
- `selectedTabPath: [Destination]` - Navigation path for current tab

#### Methods
- `navigateTo(_:for:)` - Navigate to a destination  
- `popNavigation(for:)` - Pop last destination from stack
- `popToRoot(for:)` - Clear navigation stack for tab
- `presentSheet(_:)` - Present a sheet
- `dismissSheet()` - Dismiss current sheet
- `navigate(to:)` - Navigate using a URL or URL string

### Protocols

#### DestinationType  
```swift
public protocol DestinationType: Hashable {
    /// Creates a destination from a URL path component with full path context and query parameters
    static func from(path: String, fullPath: [String], parameters: [String: String]) -> Self?
}
```

#### SheetType
```swift
public protocol SheetType: Hashable, Identifiable {}
```

#### TabType
```swift
public protocol TabType: Hashable, CaseIterable, Identifiable, Sendable {
    var icon: String { get }
}
```
*Only needed for tab-based navigation*

## URL Deep Linking

AppRouter supports URL-based deep linking, allowing you to navigate to specific screens in your app using URLs. This works with both `Router` and `SimpleRouter`.

### Setting Up Deep Linking

#### 1. Implement URL Parsing in Your Destination Type

```swift
enum Destination: DestinationType {
    case detail(id: String)
    case list
    case profile(userId: String)
    case userDetail(id: String)     // Different from generic detail
    case postDetail(id: String)     // Different from generic detail
    
    // Required for URL deep linking with contextual routing support
    static func from(path: String, fullPath: [String], parameters: [String: String]) -> Destination? {
        // Find current position in the path for context
        guard let currentIndex = fullPath.firstIndex(of: path) else {
            return nil
        }
        
        let previousComponent = currentIndex > 0 ? fullPath[currentIndex - 1] : nil
        
        switch (previousComponent, path) {
        // Contextual routing - same path component, different destinations
        case ("users", "detail"):
            let id = parameters["id"] ?? "unknown"
            return .userDetail(id: id)
        case ("posts", "detail"):
            let id = parameters["id"] ?? "unknown"
            return .postDetail(id: id)
        // Standard routing
        case (_, "detail"):
            let id = parameters["id"] ?? "default"
            return .detail(id: id)
        case (_, "list"):
            return .list
        case (_, "profile"):
            let userId = parameters["userId"] ?? "unknown"
            return .profile(userId: userId)
        case (nil, "users"), (nil, "posts"):
            return nil // These are path segments, not destinations
        default:
            return nil
        }
    }
}
```

#### 2. Handle Incoming URLs with SwiftUI's .openURL

```swift
struct ContentView: View {
    @State private var router = SimpleRouter<Destination, Sheet>()
    
    var body: some View {
        NavigationStack(path: $router.path) {
            HomeView()
                .navigationDestination(for: Destination.self) { destination in
                    destinationView(for: destination)
                }
        }
        .environment(router)
        .onOpenURL { url in
            // Handle deep links
            router.navigate(to: url)
        }
    }
}
```

#### 3. Configure Your App's URL Scheme

Add your URL scheme to your app's `Info.plist`:

```xml
<key>CFBundleURLTypes</key>
<array>
    <dict>
        <key>CFBundleURLName</key>
        <string>myapp.deeplink</string>
        <key>CFBundleURLSchemes</key>
        <array>
            <string>myapp</string>
        </array>
    </dict>
</array>
```

### URL Format

URLs follow this format: `scheme://destination1/destination2?param1=value1&param2=value2`

#### Examples

```swift
// Navigate to a single destination
"myapp://list"

// Navigate to a destination with parameters
"myapp://detail?id=123"

// Navigate through multiple destinations (navigation stack)
"myapp://list/detail?id=456"

// Contextual routing - same path, different destinations
"myapp://users/detail?id=user123"  // ‚Üí userDetail(id: "user123")
"myapp://posts/detail?id=post456"  // ‚Üí postDetail(id: "post456")
"myapp://detail?id=generic789"     // ‚Üí detail(id: "generic789")

// Complex navigation with context
"myapp://list/users/detail?id=john&tab=profile"
```

### Contextual Routing

AppRouter supports **contextual routing** where the same path component can create different destinations based on the preceding path. This mirrors web routing patterns where `/users/detail` and `/posts/detail` are different routes.

```swift
// Different destinations from the same "detail" path:
"myapp://users/detail?id=123"  // Creates userDetail(id: "123")
"myapp://posts/detail?id=456"  // Creates postDetail(id: "456") 
"myapp://detail?id=789"        // Creates detail(id: "789")
```

This enables more natural URL structures that match REST API patterns and web conventions.

### Using Deep Links Programmatically

#### Create URLs for Sharing

```swift
// Using the URL helper extension
let url = URL.deepLink(
    scheme: "myapp",
    destinations: [Destination.detail(id: "123")],
    parameters: ["source": "share"]
)

// Share the URL
if let url = url {
    let activityVC = UIActivityViewController(activityItems: [url], applicationActivities: nil)
    // Present activity controller
}
```

#### Navigate Programmatically

```swift
struct HomeView: View {
    @Environment(SimpleRouter<Destination, Sheet>.self) private var router
    
    var body: some View {
        VStack {
            Button("Deep Link to Detail") {
                router.navigate(to: "myapp://detail?id=456")
            }
            
            Button("Navigate with URL") {
                let url = URL(string: "myapp://list/detail?id=789")!
                router.navigate(to: url)
            }
        }
    }
}
```

### Tab-Based Apps

For tab-based apps using `Router`, deep links navigate to the **currently selected tab**:

```swift
struct TabContentView: View {
    @State private var router = Router<AppTab, Destination, Sheet>(initialTab: .home)
    
    var body: some View {
        TabView(selection: $router.selectedTab) {
            // ... tab content
        }
        .onOpenURL { url in
            // This will navigate in the currently active tab
            router.navigate(to: url)
        }
    }
}
```

### Advanced URL Handling

#### Custom URL Processing

```swift
// Handle URLs manually for custom logic
@Environment(AppRouter.self) private var router

func handleCustomURL(_ url: URL) {
    // Add custom pre-processing
    guard url.scheme == "myapp" else { return }
    
    // Log analytics
    Analytics.track("deep_link_opened", parameters: ["url": url.absoluteString])
    
    // Navigate using the router
    let success = router.navigate(to: url)
    
    if !success {
        // Handle failed navigation
        showErrorAlert("Invalid deep link")
    }
}
```

#### URL Validation

```swift
extension Destination {
    static func from(path: String, fullPath: [String], parameters: [String: String]) -> Destination? {
        guard let currentIndex = fullPath.firstIndex(of: path) else {
            return nil
        }
        
        let previousComponent = currentIndex > 0 ? fullPath[currentIndex - 1] : nil
        
        switch (previousComponent, path) {
        case ("users", "detail"):
            // Validate required parameters for user detail
            guard let id = parameters["id"], !id.isEmpty else {
                return nil
            }
            return .userDetail(id: id)
        case (_, "profile"):
            guard let userId = parameters["userId"], 
                  userId.count >= 3 else {
                return nil
            }
            return .profile(userId: userId)
        default:
            return nil
        }
    }
}
```

### Testing Deep Links

#### iOS Simulator
```bash
# Open deep link in simulator
xcrun simctl openurl booted "myapp://detail?id=123"

# Test contextual routing
xcrun simctl openurl booted "myapp://users/detail?id=user123"
xcrun simctl openurl booted "myapp://posts/detail?id=post456"
```

#### Xcode Debugging
1. Edit your scheme
2. Go to "Run" ‚Üí "Arguments" ‚Üí "Arguments Passed On Launch"
3. Add: `-FIRDebugEnabled`
4. Go to "Options" ‚Üí "URL Arguments"
5. Add your test URL: `myapp://detail?id=test`

## Examples

### Type Aliases for Cleaner Syntax

To avoid verbose generic syntax throughout your app, create a type alias:

```swift
// Define once in your app
typealias AppRouter = Router<AppTab, Destination, Sheet>
typealias AppSimpleRouter = SimpleRouter<Destination, Sheet>

// Then use the cleaner syntax everywhere
@Environment(AppRouter.self) private var router
@State private var router = AppRouter(initialTab: .home)
```

### Navigate Programmatically

```swift
struct HomeView: View {
    @Environment(AppRouter.self) private var router
    
    var body: some View {
        VStack {
            Button("Go to Detail") {
                router.navigateTo(.detail(id: "123"))
            }
            
            Button("Show Settings") {
                router.presentSheet(.settings)
            }
            
            Button("Go to Profile Tab") {
                router.selectedTab = .profile
                router.navigateTo(.profile(userId: "user123"), for: .profile)
            }
        }
    }
}
```

### Environment Integration

```swift
struct App: View {
    @State private var router = Router<AppTab, Destination, Sheet>(initialTab: .home)
    
    var body: some View {
        ContentView()
            .environment(router)
            .environment(\.currentTab, router.selectedTab)
    }
}
```

## Requirements

- iOS 17.0+
- macOS 14.0+
- tvOS 17.0+  
- watchOS 10.0+
- Swift 5.9+

## License

MIT License - see LICENSE file for details
