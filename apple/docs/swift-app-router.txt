Directory Structure:

└── ./
    ├── Examples
    │   ├── AppRouter.swift
    │   └── URLRoutingExample.swift
    ├── Sources
    │   └── AppRouter
    │       ├── Extensions.swift
    │       ├── Protocols.swift
    │       ├── Router.swift
    │       ├── SimpleRouter.swift
    │       └── URLNavigationHelper.swift
    ├── Tests
    │   └── AppRouterTests
    │       ├── AppRouterTests.swift
    │       └── SimpleRouterTests.swift
    ├── CLAUDE.md
    ├── Package.swift
    └── README.md



---
File: /Examples/AppRouter.swift
---

/// AppRouter - A generic tab-based navigation router for SwiftUI
///
/// This library provides a reusable navigation state management solution for SwiftUI apps
/// that use tab-based navigation with navigation stacks and sheet presentation.
///
/// ## Key Features
/// - Generic tab system that works with any tab type
/// - Per-tab navigation stacks
/// - Sheet presentation management
/// - SwiftUI @Observable integration
/// - Thread-safe @MainActor implementation
///
/// ## Usage
///
/// 1. Define your tab type conforming to `TabType`:
/// ```swift
/// enum AppTab: String, TabType, CaseIterable {
///     case home, profile, settings
///
///     var id: String { rawValue }
///     var icon: String {
///         switch self {
///         case .home: return "house"
///         case .profile: return "person"
///         case .settings: return "gear"
///         }
///     }
/// }
/// ```
///
/// 2. Define your destination and sheet types:
/// ```swift
/// enum Destination: DestinationType {
///     case detail(String)
///     case list
/// }
///
/// enum Sheet: SheetType {
///     case settings
///     case profile
///     var id: Int { hashValue }
/// }
/// ```
///
/// 3. Create a type alias for cleaner syntax:
/// ```swift
/// typealias AppRouter = Router<AppTab, Destination, Sheet>
/// ```
///
/// 4. Create and use the router:
/// ```swift
/// @State private var router = AppRouter(initialTab: .home)
///
/// var body: some View {
///     TabView(selection: $router.selectedTab) {
///         ForEach(AppTab.allCases) { tab in
///             NavigationStack(path: $router[tab]) {
///                 ContentView()
///             }
///             .tabItem {
///                 Label(tab.rawValue, systemImage: tab.icon)
///             }
///             .tag(tab)
///         }
///     }
///     .sheet(item: $router.presentedSheet) { sheet in
///         SheetView(sheet: sheet)
///     }
///     .environment(router)
/// }
/// ```
///
/// 5. Use the router in child views:
/// ```swift
/// struct ContentView: View {
///     @Environment(AppRouter.self) private var router
///
///     var body: some View {
///         Button("Navigate") {
///             router.navigateTo(.detail("example"))
///         }
///     }
/// }
/// ```



---
File: /Examples/URLRoutingExample.swift
---

import AppRouter
import SwiftUI

// MARK: - Example App with URL Deep Linking

@main
struct URLRoutingExampleApp: App {
  var body: some Scene {
    WindowGroup {
      URLRoutingContentView()
    }
  }
}

// MARK: - Destination Types

enum Destination: DestinationType {
  case list
  case detail(id: String)
  case profile(userId: String)
  case settings
  case userDetail(id: String)
  case postDetail(id: String)

  // Required for URL deep linking with full path context
  static func from(path: String, fullPath: [String], parameters: [String: String]) -> Destination? {
    // Find the current path index to get context
    guard let currentIndex = fullPath.firstIndex(of: path) else {
      return nil
    }

    let previousComponent = currentIndex > 0 ? fullPath[currentIndex - 1] : nil

    switch (previousComponent, path) {
    case ("users", "detail"):
      let id = parameters["id"] ?? "unknown"
      return .userDetail(id: id)
    case ("posts", "detail"):
      let id = parameters["id"] ?? "unknown"
      return .postDetail(id: id)
    case (_, "list"):
      return .list
    case (_, "detail"):
      let id = parameters["id"] ?? "unknown"
      return .detail(id: id)
    case (_, "profile"):
      let userId = parameters["userId"] ?? "guest"
      return .profile(userId: userId)
    case (_, "settings"):
      return .settings
    case (nil, "users"), (nil, "posts"):
      return nil  // These are just path segments, not destinations
    default:
      return nil
    }
  }
}

enum Sheet: SheetType {
  case compose
  case help

  var id: Int { hashValue }
}

// MARK: - Main Content View

struct URLRoutingContentView: View {
  @State private var router = SimpleRouter<Destination, Sheet>()

  var body: some View {
    NavigationStack(path: $router.path) {
      HomeView()
        .navigationDestination(for: Destination.self) { destination in
          destinationView(for: destination)
        }
        .navigationTitle("URL Routing Demo")
    }
    .sheet(item: $router.presentedSheet) { sheet in
      sheetView(for: sheet)
    }
    .environment(router)
    .onOpenURL { url in
      // This is the key integration with SwiftUI's URL handling
      print("📱 Received URL: \(url)")
      let success = router.navigate(to: url)
      print(success ? "✅ Navigation successful" : "❌ Navigation failed")
    }
  }

  @ViewBuilder
  private func destinationView(for destination: Destination) -> some View {
    switch destination {
    case .list:
      ListView()
    case .detail(let id):
      DetailView(id: id)
    case .profile(let userId):
      ProfileView(userId: userId)
    case .settings:
      SettingsView()
    case .userDetail(let id):
      UserDetailView(id: id)
    case .postDetail(let id):
      PostDetailView(id: id)
    }
  }

  @ViewBuilder
  private func sheetView(for sheet: Sheet) -> some View {
    NavigationStack {
      switch sheet {
      case .compose:
        ComposeView()
      case .help:
        HelpView()
      }
    }
  }
}

// MARK: - Views

struct HomeView: View {
  @Environment(SimpleRouter<Destination, Sheet>.self) private var router

  var body: some View {
    VStack(spacing: 20) {
      Text("🔗 URL Deep Linking Demo")
        .font(.largeTitle)
        .multilineTextAlignment(.center)

      Text("Try these deep links:")
        .font(.headline)

      VStack(alignment: .leading, spacing: 12) {
        DeepLinkButton(
          title: "List View",
          url: "myapp://list",
          router: router
        )

        DeepLinkButton(
          title: "Detail with ID",
          url: "myapp://detail?id=123",
          router: router
        )

        DeepLinkButton(
          title: "User Profile",
          url: "myapp://profile?userId=john",
          router: router
        )

        DeepLinkButton(
          title: "Navigation Stack",
          url: "myapp://list/detail?id=456",
          router: router
        )

        DeepLinkButton(
          title: "Settings",
          url: "myapp://settings",
          router: router
        )

        DeepLinkButton(
          title: "User Detail (Contextual)",
          url: "myapp://users/detail?id=user123",
          router: router
        )

        DeepLinkButton(
          title: "Post Detail (Contextual)",
          url: "myapp://posts/detail?id=post456",
          router: router
        )
      }

      Divider()

      Text("📋 Current Navigation Path:")
        .font(.headline)

      if router.path.isEmpty {
        Text("Root")
          .foregroundColor(.secondary)
      } else {
        ForEach(Array(router.path.enumerated()), id: \.offset) { index, destination in
          HStack {
            Text("\(index + 1).")
            Text("\(String(describing: destination))")
            Spacer()
          }
          .padding(.horizontal)
          .padding(.vertical, 4)
          .background(Color.blue.opacity(0.1))
          .cornerRadius(8)
        }
      }

      Spacer()

      VStack(spacing: 8) {
        Button("🗂 Show Compose Sheet") {
          router.presentSheet(.compose)
        }
        .buttonStyle(.borderedProminent)

        if !router.path.isEmpty {
          Button("↩️ Pop Navigation") {
            router.popNavigation()
          }
          .buttonStyle(.bordered)

          Button("🏠 Pop to Root") {
            router.popToRoot()
          }
          .buttonStyle(.bordered)
        }
      }
    }
    .padding()
  }
}

struct DeepLinkButton: View {
  let title: String
  let url: String
  let router: SimpleRouter<Destination, Sheet>

  var body: some View {
    VStack(alignment: .leading, spacing: 4) {
      Button(title) {
        router.navigate(to: url)
      }
      .buttonStyle(.bordered)

      Text(url)
        .font(.caption)
        .foregroundColor(.secondary)
        .padding(.leading, 16)
    }
  }
}

struct ListView: View {
  @Environment(SimpleRouter<Destination, Sheet>.self) private var router

  var body: some View {
    List {
      ForEach(1...10, id: \.self) { index in
        Button("Item \(index)") {
          router.navigateTo(.detail(id: "item-\(index)"))
        }
      }
    }
    .navigationTitle("List")
    .navigationBarTitleDisplayMode(.large)
  }
}

struct DetailView: View {
  let id: String
  @Environment(SimpleRouter<Destination, Sheet>.self) private var router

  var body: some View {
    VStack(spacing: 20) {
      Text("📄 Detail View")
        .font(.largeTitle)

      Text("ID: \(id)")
        .font(.title2)
        .padding()
        .background(Color.blue.opacity(0.1))
        .cornerRadius(8)

      Button("Go to Settings") {
        router.navigateTo(.settings)
      }
      .buttonStyle(.borderedProminent)

      Button("View Profile") {
        router.navigateTo(.profile(userId: "user-from-detail"))
      }
      .buttonStyle(.bordered)

      Spacer()
    }
    .padding()
    .navigationTitle("Detail")
  }
}

struct ProfileView: View {
  let userId: String

  var body: some View {
    VStack(spacing: 20) {
      Text("👤 Profile View")
        .font(.largeTitle)

      Text("User ID: \(userId)")
        .font(.title2)
        .padding()
        .background(Color.green.opacity(0.1))
        .cornerRadius(8)

      Image(systemName: "person.circle.fill")
        .font(.system(size: 80))
        .foregroundColor(.blue)

      Text("Welcome, \(userId)!")
        .font(.headline)

      Spacer()
    }
    .padding()
    .navigationTitle("Profile")
  }
}

struct SettingsView: View {
  var body: some View {
    Form {
      Section("App Settings") {
        HStack {
          Text("Notifications")
          Spacer()
          Toggle("", isOn: .constant(true))
        }

        HStack {
          Text("Dark Mode")
          Spacer()
          Toggle("", isOn: .constant(false))
        }
      }

      Section("About") {
        Text("URL Routing Demo v1.0")
        Text("Built with AppRouter")
      }
    }
    .navigationTitle("Settings")
  }
}

struct ComposeView: View {
  @Environment(\.dismiss) private var dismiss

  var body: some View {
    VStack(spacing: 20) {
      Text("✍️ Compose")
        .font(.largeTitle)

      TextEditor(text: .constant("Write something..."))
        .border(Color.gray, width: 1)
        .frame(height: 200)

      Button("Done") {
        dismiss()
      }
      .buttonStyle(.borderedProminent)

      Spacer()
    }
    .padding()
    .navigationTitle("Compose")
    .navigationBarTitleDisplayMode(.inline)
    .toolbar {
      ToolbarItem(placement: .navigationBarLeading) {
        Button("Cancel") {
          dismiss()
        }
      }
    }
  }
}

struct HelpView: View {
  var body: some View {
    VStack {
      Text("Help")
        .font(.largeTitle)

      Text("This is a help view")

      Spacer()
    }
    .padding()
  }
}

struct UserDetailView: View {
  let id: String

  var body: some View {
    VStack(spacing: 20) {
      Text("👤 User Detail")
        .font(.largeTitle)

      Text("User ID: \(id)")
        .font(.title2)
        .padding()
        .background(Color.blue.opacity(0.1))
        .cornerRadius(8)

      Image(systemName: "person.circle")
        .font(.system(size: 60))
        .foregroundColor(.blue)

      Text("This is a specific user detail view, different from a generic detail view")
        .multilineTextAlignment(.center)
        .foregroundColor(.secondary)

      Spacer()
    }
    .padding()
    .navigationTitle("User Details")
  }
}

struct PostDetailView: View {
  let id: String

  var body: some View {
    VStack(spacing: 20) {
      Text("📝 Post Detail")
        .font(.largeTitle)

      Text("Post ID: \(id)")
        .font(.title2)
        .padding()
        .background(Color.green.opacity(0.1))
        .cornerRadius(8)

      Image(systemName: "doc.text")
        .font(.system(size: 60))
        .foregroundColor(.green)

      Text("This is a specific post detail view, different from a generic detail view")
        .multilineTextAlignment(.center)
        .foregroundColor(.secondary)

      Spacer()
    }
    .padding()
    .navigationTitle("Post Details")
  }
}

// MARK: - URL Scheme Configuration

/*
 Add this to your Info.plist to handle the "myapp://" URL scheme:

 <key>CFBundleURLTypes</key>
 <array>
     <dict>
         <key>CFBundleURLName</key>
         <string>myapp.deeplink</string>
         <key>CFBundleURLSchemes</key>
         <array>
             <string>myapp</string>
         </array>
     </dict>
 </array>

 Test URLs in iOS Simulator:
 xcrun simctl openurl booted "myapp://list"
 xcrun simctl openurl booted "myapp://detail?id=test123"
 xcrun simctl openurl booted "myapp://profile?userId=alice"
 xcrun simctl openurl booted "myapp://list/detail?id=deep-link"
 xcrun simctl openurl booted "myapp://users/detail?id=user123"
 xcrun simctl openurl booted "myapp://posts/detail?id=post456"
 */



---
File: /Sources/AppRouter/Extensions.swift
---

import Foundation
import SwiftUI

// MARK: - Environment Extensions

extension EnvironmentValues {
  /// The currently active tab in the environment
  @Entry public var currentTab: (any TabType)? = nil
}

// MARK: - URL Extensions

extension URL {
  /// Creates a URL for deep linking with the specified destinations
  /// - Parameters:
  ///   - scheme: The URL scheme (e.g., "myapp")
  ///   - destinations: Array of destinations to navigate through
  ///   - parameters: Query parameters to include
  /// - Returns: A URL for deep linking, or nil if construction fails
  public static func deepLink<Destination: DestinationType>(
    scheme: String,
    destinations: [Destination],
    parameters: [String: String] = [:]
  ) -> URL? {
    guard !destinations.isEmpty else { return nil }

    var components = URLComponents()
    components.scheme = scheme

    // Use host for the first destination
    components.host = String(describing: destinations.first!)

    // Add remaining destinations as path if they exist
    if destinations.count > 1 {
      components.path =
        "/" + destinations.dropFirst().map { String(describing: $0) }.joined(separator: "/")
    }

    if !parameters.isEmpty {
      components.queryItems = parameters.map { URLQueryItem(name: $0.key, value: $0.value) }
    }

    return components.url
  }
}



---
File: /Sources/AppRouter/Protocols.swift
---

import SwiftUI

/// A type that can serve as a navigation destination.
public protocol DestinationType: Hashable {
  /// Creates a destination from a URL path component with full path context and query parameters
  /// - Parameters:
  ///   - path: The current URL path component
  ///   - fullPath: The complete array of path components for context
  ///   - parameters: Query parameters from the URL
  /// - Returns: A destination instance if the path matches, nil otherwise
  static func from(path: String, fullPath: [String], parameters: [String: String]) -> Self?
}

/// A type that can be presented as a sheet.
public protocol SheetType: Hashable, Identifiable {}

/// A type that can serve as a tab in a tab-based navigation system.
/// Only needed when using the full Router<Tab, Destination, Sheet> for tab-based navigation.
public protocol TabType: Hashable, CaseIterable, Identifiable, Sendable {
  /// The icon name (SF Symbol) for this tab
  var icon: String { get }
}



---
File: /Sources/AppRouter/Router.swift
---

import Foundation
import SwiftUI

/// A generic navigation router that manages tab-based navigation state with navigation stacks and sheet presentation.
@Observable
@MainActor
public final class Router<Tab: TabType, Destination: DestinationType, Sheet: SheetType> {

  // MARK: - Private Properties

  /// Navigation paths for each tab
  private var paths: [Tab: [Destination]] = [:]

  // MARK: - Public Properties

  /// The currently selected tab
  public var selectedTab: Tab

  /// The currently presented sheet, if any
  public var presentedSheet: Sheet?

  // MARK: - Initialization

  /// Creates a new router with the specified initial tab.
  /// - Parameter initialTab: The tab to select when the router is created
  public init(initialTab: Tab) {
    self.selectedTab = initialTab
  }

  // MARK: - Path Access

  /// Subscript access to navigation paths for each tab
  public subscript(tab: Tab) -> [Destination] {
    get { paths[tab] ?? [] }
    set { paths[tab] = newValue }
  }

  /// The navigation path for the currently selected tab
  public var selectedTabPath: [Destination] {
    paths[selectedTab] ?? []
  }

  // MARK: - Navigation Methods

  /// Pops the navigation stack to the root for the specified tab (or current tab if nil).
  /// - Parameter tab: The tab to pop to root. If nil, uses the currently selected tab.
  public func popToRoot(for tab: Tab? = nil) {
    paths[tab ?? selectedTab] = []
  }

  /// Pops the last destination from the navigation stack for the specified tab.
  /// - Parameter tab: The tab to pop from. If nil, uses the currently selected tab.
  public func popNavigation(for tab: Tab? = nil) {
    let targetTab = tab ?? selectedTab
    if paths[targetTab]?.isEmpty == false {
      paths[targetTab]?.removeLast()
    }
  }

  /// Navigates to the specified destination for the specified tab.
  /// - Parameters:
  ///   - destination: The destination to navigate to
  ///   - tab: The tab to navigate in. If nil, uses the currently selected tab.
  public func navigateTo(_ destination: Destination, for tab: Tab? = nil) {
    let targetTab = tab ?? selectedTab
    if paths[targetTab] == nil {
      paths[targetTab] = [destination]
    } else {
      paths[targetTab]?.append(destination)
    }
  }

  // MARK: - Sheet Methods

  /// Presents the specified sheet.
  /// - Parameter sheet: The sheet to present
  public func presentSheet(_ sheet: Sheet) {
    presentedSheet = sheet
  }

  /// Dismisses the currently presented sheet.
  public func dismissSheet() {
    presentedSheet = nil
  }

  // MARK: - URL Routing Methods

  /// Navigates to a URL by parsing its components and routing accordingly
  /// - Parameter url: The URL to navigate to
  /// - Returns: True if the URL was successfully routed, false otherwise
  @discardableResult
  public func navigate(to url: URL) -> Bool {
    return URLNavigationHelper.navigate(url: url) { destinations in
      paths[selectedTab] = destinations
    }
  }

  /// Navigates to a URL string by parsing its components and routing accordingly
  /// - Parameter urlString: The URL string to navigate to
  /// - Returns: True if the URL was successfully routed, false otherwise
  @discardableResult
  public func navigate(to urlString: String) -> Bool {
    guard let url = URL(string: urlString) else {
      return false
    }
    return navigate(to: url)
  }
}



---
File: /Sources/AppRouter/SimpleRouter.swift
---

import Foundation
import SwiftUI

/// A simple navigation router for single-stack navigation with sheet presentation.
/// Use this when you don't need tab-based navigation, just a single NavigationStack.
@Observable
@MainActor
public final class SimpleRouter<Destination: DestinationType, Sheet: SheetType> {

  // MARK: - Public Properties

  /// The navigation path for the router
  public var path: [Destination] = []

  /// The currently presented sheet, if any
  public var presentedSheet: Sheet?

  // MARK: - Initialization

  /// Creates a new simple router
  public init() {}

  // MARK: - Navigation Methods

  /// Pops the navigation stack to the root
  public func popToRoot() {
    path = []
  }

  /// Pops the last destination from the navigation stack
  public func popNavigation() {
    if !path.isEmpty {
      path.removeLast()
    }
  }

  /// Navigates to the specified destination
  /// - Parameter destination: The destination to navigate to
  public func navigateTo(_ destination: Destination) {
    path.append(destination)
  }

  // MARK: - Sheet Methods

  /// Presents the specified sheet
  /// - Parameter sheet: The sheet to present
  public func presentSheet(_ sheet: Sheet) {
    presentedSheet = sheet
  }

  /// Dismisses the currently presented sheet
  public func dismissSheet() {
    presentedSheet = nil
  }

  // MARK: - URL Routing Methods

  /// Navigates to a URL by parsing its components and routing accordingly
  /// - Parameter url: The URL to navigate to
  /// - Returns: True if the URL was successfully routed, false otherwise
  @discardableResult
  public func navigate(to url: URL) -> Bool {
    return URLNavigationHelper.navigate(url: url) { destinations in
      path = destinations
    }
  }

  /// Navigates to a URL string by parsing its components and routing accordingly
  /// - Parameter urlString: The URL string to navigate to
  /// - Returns: True if the URL was successfully routed, false otherwise
  @discardableResult
  public func navigate(to urlString: String) -> Bool {
    guard let url = URL(string: urlString) else {
      return false
    }
    return navigate(to: url)
  }
}



---
File: /Sources/AppRouter/URLNavigationHelper.swift
---

import Foundation

/// Helper for shared URL navigation logic
internal enum URLNavigationHelper {
  /// Navigates to a URL by parsing its components and applying destinations
  /// - Parameters:
  ///   - url: The URL to navigate to
  ///   - applyDestinations: Closure that applies the parsed destinations
  /// - Returns: True if navigation was successful, false otherwise
  static func navigate<Destination: DestinationType>(
    url: URL,
    applyDestinations: ([Destination]) -> Void
  ) -> Bool {
    guard let components = URLComponents(url: url, resolvingAgainstBaseURL: false) else {
      return false
    }

    // Extract path components from host and path (e.g., myapp://detail/list)
    var pathComponents: [String] = []

    // Start with host as first component
    if let host = components.host {
      pathComponents.append(host)
    }

    // Add path components if they exist
    if !components.path.isEmpty {
      let pathParts = components.path.split(separator: "/").map(String.init).filter { !$0.isEmpty }
      pathComponents.append(contentsOf: pathParts)
    }

    guard !pathComponents.isEmpty else { return false }

    let queryParameters = parseQueryParameters(from: components.queryItems)

    // Convert path components to destinations
    var destinations: [Destination] = []
    for pathComponent in pathComponents {
      if let destination = Destination.from(
        path: pathComponent, fullPath: pathComponents, parameters: queryParameters)
      {
        destinations.append(destination)
      }
    }

    guard !destinations.isEmpty else { return false }

    applyDestinations(destinations)
    return true
  }

  /// Parses query parameters from URL components
  /// - Parameter queryItems: Array of URLQueryItem from URLComponents
  /// - Returns: Dictionary of query parameters
  private static func parseQueryParameters(from queryItems: [URLQueryItem]?) -> [String: String] {
    guard let queryItems = queryItems else { return [:] }

    var parameters: [String: String] = [:]
    for item in queryItems {
      if let value = item.value {
        parameters[item.name] = value
      }
    }
    return parameters
  }
}



---
File: /Tests/AppRouterTests/AppRouterTests.swift
---

import XCTest

@testable import AppRouter

// Test types
enum TestTab: String, TabType, CaseIterable {
  case home, profile, settings

  var id: String { rawValue }
  var icon: String { "house" }
}

enum TestDestination: DestinationType {
  case detail(String)
  case list
  case userDetail(String)
  case postDetail(String)

  static func from(path: String, fullPath: [String], parameters: [String: String])
    -> TestDestination?
  {
    guard let currentIndex = fullPath.firstIndex(of: path) else {
      return nil
    }

    let previousComponent = currentIndex > 0 ? fullPath[currentIndex - 1] : nil

    switch (previousComponent, path) {
    case ("users", "detail"):
      let id = parameters["id"] ?? "unknown"
      return .userDetail(id)
    case ("posts", "detail"):
      let id = parameters["id"] ?? "unknown"
      return .postDetail(id)
    case (_, "list"):
      return .list
    case (_, "detail"):
      if let id = parameters["id"] {
        return .detail(id)
      }
      return .detail("default")
    case (nil, "users"), (nil, "posts"):
      return nil  // These are just path segments, not destinations
    default:
      return nil
    }
  }
}

enum TestSheet: SheetType {
  case settings
  case profile

  var id: Int { hashValue }
}

@MainActor
final class AppRouterTests: XCTestCase {

  var router: Router<TestTab, TestDestination, TestSheet>!

  override func setUp() {
    super.setUp()
    router = Router(initialTab: .home)
  }

  override func tearDown() {
    router = nil
    super.tearDown()
  }

  func testInitialState() {
    XCTAssertEqual(router.selectedTab, .home)
    XCTAssertNil(router.presentedSheet)
    XCTAssertTrue(router.selectedTabPath.isEmpty)
  }

  func testNavigation() {
    router.navigateTo(.detail("test"))
    XCTAssertEqual(router.selectedTabPath.count, 1)

    router.navigateTo(.list)
    XCTAssertEqual(router.selectedTabPath.count, 2)
  }

  func testPopNavigation() {
    router.navigateTo(.detail("test"))
    router.navigateTo(.list)

    router.popNavigation()
    XCTAssertEqual(router.selectedTabPath.count, 1)

    router.popNavigation()
    XCTAssertTrue(router.selectedTabPath.isEmpty)
  }

  func testPopToRoot() {
    router.navigateTo(.detail("test"))
    router.navigateTo(.list)

    router.popToRoot()
    XCTAssertTrue(router.selectedTabPath.isEmpty)
  }

  func testPerTabNavigation() {
    router.navigateTo(.detail("home"), for: .home)
    router.navigateTo(.list, for: .profile)

    XCTAssertEqual(router[.home].count, 1)
    XCTAssertEqual(router[.profile].count, 1)
    XCTAssertTrue(router[.settings].isEmpty)
  }

  func testSheetPresentation() {
    router.presentSheet(.settings)
    XCTAssertEqual(router.presentedSheet, .settings)

    router.dismissSheet()
    XCTAssertNil(router.presentedSheet)
  }

  func testTabSwitching() {
    router.selectedTab = .profile
    XCTAssertEqual(router.selectedTab, .profile)

    router.navigateTo(.detail("profile"))
    XCTAssertEqual(router.selectedTabPath.count, 1)

    router.selectedTab = .home
    XCTAssertTrue(router.selectedTabPath.isEmpty)
    XCTAssertEqual(router[.profile].count, 1)
  }

  // MARK: - URL Routing Tests

  func testURLNavigationToSingleDestination() {
    let result = router.navigate(to: "myapp://list")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)
    XCTAssertEqual(router.selectedTabPath[0], .list)
  }

  func testURLNavigationToDestinationWithParameters() {
    let result = router.navigate(to: "myapp://detail?id=123")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)

    if case let .detail(id) = router.selectedTabPath.first {
      XCTAssertEqual(id, "123")
    } else {
      XCTFail("Expected detail destination with id")
    }
  }

  func testURLNavigationToMultipleDestinations() {
    let result = router.navigate(to: "myapp://list/detail")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 2)

    XCTAssertEqual(router.selectedTabPath[0], .list)
    if case let .detail(id) = router.selectedTabPath[1] {
      XCTAssertEqual(id, "default")  // Should get default since no parameter
    } else {
      XCTFail("Expected detail destination with id")
    }
  }

  func testURLNavigationWithInvalidDestination() {
    let result = router.navigate(to: "myapp://invalid")
    XCTAssertFalse(result)  // Should fail since no valid destinations
    XCTAssertTrue(router.selectedTabPath.isEmpty)  // No destinations added
  }

  func testURLNavigationWithMalformedURL() {
    let result = router.navigate(to: "not a url")
    XCTAssertFalse(result)
    XCTAssertTrue(router.selectedTabPath.isEmpty)  // Should remain unchanged
  }

  func testURLNavigationWithEmptyHost() {
    let result = router.navigate(to: "myapp://")
    XCTAssertFalse(result)
    XCTAssertTrue(router.selectedTabPath.isEmpty)  // Should remain unchanged
  }

  func testURLNavigationReplacesExistingPath() {
    // Set up existing navigation
    router.navigateTo(.detail("existing"))
    router.navigateTo(.list)
    XCTAssertEqual(router.selectedTabPath.count, 2)

    // Navigate via URL - should replace existing path
    let result = router.navigate(to: "myapp://detail?id=newValue")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)

    if case let .detail(id) = router.selectedTabPath[0] {
      XCTAssertEqual(id, "newValue")
    } else {
      XCTFail("Expected detail destination with new value")
    }
  }

  // MARK: - Contextual URL Routing Tests

  func testContextualUserDetailRoute() {
    let result = router.navigate(to: "myapp://users/detail?id=user123")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)

    if case let .userDetail(id) = router.selectedTabPath[0] {
      XCTAssertEqual(id, "user123")
    } else {
      XCTFail("Expected userDetail destination")
    }
  }

  func testContextualPostDetailRoute() {
    let result = router.navigate(to: "myapp://posts/detail?id=post456")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)

    if case let .postDetail(id) = router.selectedTabPath[0] {
      XCTAssertEqual(id, "post456")
    } else {
      XCTFail("Expected postDetail destination")
    }
  }

  func testContextualRoutingDifferentiatesDetailTypes() {
    // Test that users/detail and posts/detail create different destination types
    let userResult = router.navigate(to: "myapp://users/detail?id=123")
    XCTAssertTrue(userResult)

    if case .userDetail = router.selectedTabPath[0] {
      // Expected
    } else {
      XCTFail("Expected userDetail destination")
    }

    let postResult = router.navigate(to: "myapp://posts/detail?id=123")
    XCTAssertTrue(postResult)

    if case .postDetail = router.selectedTabPath[0] {
      // Expected
    } else {
      XCTFail("Expected postDetail destination")
    }
  }

  func testNonContextualDetailStillWorks() {
    // Test that the original detail route without context still works
    let result = router.navigate(to: "myapp://detail?id=generic")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)

    if case let .detail(id) = router.selectedTabPath[0] {
      XCTAssertEqual(id, "generic")
    } else {
      XCTFail("Expected generic detail destination")
    }
  }

  func testContextualRoutingWithoutParameters() {
    let result = router.navigate(to: "myapp://users/detail")
    XCTAssertTrue(result)
    XCTAssertEqual(router.selectedTabPath.count, 1)

    if case let .userDetail(id) = router.selectedTabPath[0] {
      XCTAssertEqual(id, "unknown")  // Should get default value
    } else {
      XCTFail("Expected userDetail destination with default id")
    }
  }
}



---
File: /Tests/AppRouterTests/SimpleRouterTests.swift
---

import XCTest

@testable import AppRouter

// Test types for SimpleRouter
enum SimpleDestination: DestinationType {
  case detail(String)
  case list
  case settings

  static func from(path: String, fullPath: [String], parameters: [String: String])
    -> SimpleDestination?
  {
    guard fullPath.contains(path) else {
      return nil
    }

    switch path {
    case "list":
      return .list
    case "settings":
      return .settings
    case "detail":
      if let id = parameters["id"] {
        return .detail(id)
      }
      return .detail("default")
    default:
      return nil
    }
  }
}

enum SimpleSheet: SheetType {
  case compose
  case settings

  var id: Int { hashValue }
}

@MainActor
final class SimpleRouterTests: XCTestCase {

  var router: SimpleRouter<SimpleDestination, SimpleSheet>!

  override func setUp() {
    super.setUp()
    router = SimpleRouter()
  }

  override func tearDown() {
    router = nil
    super.tearDown()
  }

  func testInitialState() {
    XCTAssertTrue(router.path.isEmpty)
    XCTAssertNil(router.presentedSheet)
  }

  func testNavigation() {
    router.navigateTo(.detail("test"))
    XCTAssertEqual(router.path.count, 1)

    router.navigateTo(.list)
    XCTAssertEqual(router.path.count, 2)

    router.navigateTo(.settings)
    XCTAssertEqual(router.path.count, 3)
  }

  func testPopNavigation() {
    router.navigateTo(.detail("test"))
    router.navigateTo(.list)
    router.navigateTo(.settings)

    router.popNavigation()
    XCTAssertEqual(router.path.count, 2)

    router.popNavigation()
    XCTAssertEqual(router.path.count, 1)

    router.popNavigation()
    XCTAssertTrue(router.path.isEmpty)

    // Should handle empty path gracefully
    router.popNavigation()
    XCTAssertTrue(router.path.isEmpty)
  }

  func testPopToRoot() {
    router.navigateTo(.detail("test"))
    router.navigateTo(.list)
    router.navigateTo(.settings)

    router.popToRoot()
    XCTAssertTrue(router.path.isEmpty)
  }

  func testSheetPresentation() {
    router.presentSheet(.compose)
    XCTAssertEqual(router.presentedSheet, .compose)

    router.dismissSheet()
    XCTAssertNil(router.presentedSheet)

    router.presentSheet(.settings)
    XCTAssertEqual(router.presentedSheet, .settings)

    // Test replacing current sheet
    router.presentSheet(.compose)
    XCTAssertEqual(router.presentedSheet, .compose)
  }

  func testNavigationAndSheetTogether() {
    // Test that navigation and sheet state are independent
    router.navigateTo(.detail("test"))
    router.presentSheet(.compose)

    XCTAssertEqual(router.path.count, 1)
    XCTAssertEqual(router.presentedSheet, .compose)

    router.popNavigation()
    XCTAssertTrue(router.path.isEmpty)
    XCTAssertEqual(router.presentedSheet, .compose)  // Sheet should remain

    router.dismissSheet()
    XCTAssertNil(router.presentedSheet)
  }

  // MARK: - URL Routing Tests

  func testURLNavigationToSingleDestination() {
    let result = router.navigate(to: "myapp://list")
    XCTAssertTrue(result)
    XCTAssertEqual(router.path.count, 1)
    XCTAssertEqual(router.path[0], .list)
  }

  func testURLNavigationToDestinationWithParameters() {
    let result = router.navigate(to: "myapp://detail?id=test123")
    XCTAssertTrue(result)
    XCTAssertEqual(router.path.count, 1)

    if case let .detail(id) = router.path[0] {
      XCTAssertEqual(id, "test123")
    } else {
      XCTFail("Expected detail destination with id")
    }
  }

  func testURLNavigationToMultipleDestinations() {
    let result = router.navigate(to: "myapp://list/detail/settings?id=456")
    XCTAssertTrue(result)
    XCTAssertEqual(router.path.count, 3)

    XCTAssertEqual(router.path[0], .list)
    if case let .detail(id) = router.path[1] {
      XCTAssertEqual(id, "456")
    } else {
      XCTFail("Expected detail destination with id")
    }
    XCTAssertEqual(router.path[2], .settings)
  }

  func testURLNavigationWithInvalidDestination() {
    let result = router.navigate(to: "myapp://invalid")
    XCTAssertFalse(result)  // Should fail for SimpleRouter since no valid destinations
    XCTAssertTrue(router.path.isEmpty)
  }

  func testURLNavigationWithMalformedURL() {
    let result = router.navigate(to: "not a url")
    XCTAssertFalse(result)
    XCTAssertTrue(router.path.isEmpty)
  }

  func testURLNavigationWithEmptyHost() {
    let result = router.navigate(to: "myapp://")
    XCTAssertFalse(result)
    XCTAssertTrue(router.path.isEmpty)
  }

  func testURLNavigationClearsExistingPath() {
    // Set up existing navigation
    router.navigateTo(.detail("existing"))
    router.navigateTo(.list)
    XCTAssertEqual(router.path.count, 2)

    // Navigate via URL - should replace existing path
    let result = router.navigate(to: "myapp://settings")
    XCTAssertTrue(result)
    XCTAssertEqual(router.path.count, 1)
    XCTAssertEqual(router.path[0], .settings)
  }
}



---
File: /CLAUDE.md
---

# AppRouter - Claude.md

## Project Overview
AppRouter is a SwiftUI navigation router library that provides both simple single-stack navigation (`SimpleRouter`) and complex tab-based navigation (`Router`) with independent navigation stacks and sheet presentation. The library targets iOS 17+, macOS 14+, tvOS 17+, and watchOS 10+ using Swift 5.9+.

## Build & Test Commands
```bash
# Build the package
swift build

# Run tests
swift test

# Build for specific platform
swift build --arch arm64 --target AppRouter

# Test with verbose output
swift test --verbose

# Check for Swift format/lint (if available)
swift-format --configuration .swift-format Sources/ Tests/
```

## Project Structure
- `Sources/AppRouter/` - Main library code
  - `Router.swift` - Tab-based navigation router
  - `SimpleRouter.swift` - Single-stack navigation router  
  - `Protocols.swift` - Core protocols (DestinationType, SheetType, TabType)
  - `Extensions.swift` - URL navigation helpers and extensions
  - `URLNavigationHelper.swift` - Deep linking utilities
- `Tests/AppRouterTests/` - Unit tests
- `Examples/` - Usage examples
- `Package.swift` - Swift Package Manager configuration

## Key Components

### Core Classes
- `Router<Tab, Destination, Sheet>` - Tab-based navigation with independent stacks per tab
- `SimpleRouter<Destination, Sheet>` - Single NavigationStack with sheet support
- Both are `@Observable @MainActor` for SwiftUI integration

### Protocols
- `DestinationType: Hashable` - Navigation destinations with URL parsing support
- `SheetType: Hashable, Identifiable` - Sheet presentations  
- `TabType: Hashable, CaseIterable, Identifiable, Sendable` - Tab definitions

### Navigation Methods
- `navigateTo(_:)` / `navigateTo(_:for:)` - Push destinations
- `popNavigation()` / `popToRoot()` - Pop navigation stack
- `presentSheet(_:)` / `dismissSheet()` - Sheet management
- `navigate(to: URL)` - Deep linking navigation

## Development Guidelines

### Code Style
- Follow Swift API Design Guidelines
- Use `@MainActor` for UI-related classes
- Prefer `@Observable` over `ObservableObject` for iOS 17+
- Use protocol-oriented design for flexibility
- Include comprehensive documentation comments

### Testing
- Unit tests in `Tests/AppRouterTests/`
- Test both `Router` and `SimpleRouter` functionality
- Mock destinations and sheets for testing
- Verify navigation state changes
- Test URL deep linking parsing

### URL Deep Linking
- Implement `DestinationType.from(path:parameters:)` for URL parsing
- URL format: `scheme://destination1/destination2?param1=value1`
- Support navigation through multiple destinations
- Handle URL validation and error cases

### Common Tasks
- Add new navigation methods to both Router classes
- Extend protocols for additional functionality  
- Update Examples/ with new features
- Ensure thread safety with `@MainActor`
- Maintain backwards compatibility within major versions

## Example Usage Patterns

### Simple Router Setup
```swift
@State private var router = SimpleRouter<Destination, Sheet>()

NavigationStack(path: $router.path) {
    // Root view
}.environment(router)
```

### Tab Router Setup  
```swift
@State private var router = Router<AppTab, Destination, Sheet>(initialTab: .home)

TabView(selection: $router.selectedTab) {
    // Tab content with NavigationStack(path: $router[tab])
}.environment(router)
```

### Navigation Usage
```swift
@Environment(AppRouter.self) private var router

router.navigateTo(.detail(id: "123"))
router.presentSheet(.settings)
router.navigate(to: "myapp://detail?id=456")
```

## Dependencies
- No external dependencies
- Uses only SwiftUI and Foundation
- Swift Package Manager for distribution

## Platform Support
- iOS 17.0+
- macOS 14.0+ 
- tvOS 17.0+
- watchOS 10.0+
- Swift 5.9+


---
File: /Package.swift
---

// swift-tools-version: 5.9
import PackageDescription

let package = Package(
    name: "AppRouter",
    platforms: [
        .iOS(.v17),
        .macOS(.v14),
        .tvOS(.v17),
        .watchOS(.v10)
    ],
    products: [
        .library(
            name: "AppRouter",
            targets: ["AppRouter"]),
    ],
    targets: [
        .target(
            name: "AppRouter"),
        .testTarget(
            name: "AppRouterTests",
            dependencies: ["AppRouter"]),
    ]
)


---
File: /README.md
---

# AppRouter

A generic, reusable navigation router for SwiftUI applications. Supports both simple single-stack navigation and complex tab-based navigation with independent navigation stacks and sheet presentation.

## Features

- 🎯 **Simple Router** - `SimpleRouter` for single NavigationStack apps
- 🏷️ **Tab Router** - `Router` for tab-based apps with independent navigation per tab
- 📄 **Sheet Management** - Built-in sheet presentation and dismissal
- 🔄 **SwiftUI Integration** - Uses `@Observable` for reactive state updates
- 🧵 **Thread Safe** - `@MainActor` implementation ensures UI safety
- 📱 **iOS 17+ Ready** - Built for modern SwiftUI patterns
- 🔗 **URL Deep Linking** - Navigate via URLs with automatic parameter parsing
- 🛤️ **Contextual Routing** - Same path components create different destinations based on context (e.g., `/users/detail` vs `/posts/detail`)

## Installation

### Swift Package Manager

Add this package to your project:

```swift
dependencies: [
    .package(url: "https://github.com/dimillian/AppRouter.git", from: "1.0.0")
]
```

## Quick Start

AppRouter provides two routers depending on your app's navigation needs:

- **`SimpleRouter`** - For apps with a single NavigationStack
- **`Router`** - For apps with tab-based navigation

### Option 1: Simple Navigation (Single Stack)

Perfect for apps that don't use tabs and just need a single navigation stack with sheet support.

```swift
import SwiftUI
import AppRouter

// 1. Define your destination and sheet types
enum Destination: DestinationType {
    case detail(id: String)
    case settings
    case profile(userId: String)
}

enum Sheet: SheetType {
    case compose
    case settings
    
    var id: Int { hashValue }
}

// 2. Use SimpleRouter
struct ContentView: View {
    @State private var router = SimpleRouter<Destination, Sheet>()
    
    var body: some View {
        NavigationStack(path: $router.path) {
            HomeView()
                .navigationDestination(for: Destination.self) { destination in
                    destinationView(for: destination)
                }
        }
        .sheet(item: $router.presentedSheet) { sheet in
            sheetView(for: sheet)
        }
        .environment(router)
    }
    
    @ViewBuilder
    private func destinationView(for destination: Destination) -> some View {
        switch destination {
        case .detail(let id):
            DetailView(id: id)
        case .settings:
            SettingsView()
        case .profile(let userId):
            ProfileView(userId: userId)
        }
    }
    
    @ViewBuilder
    private func sheetView(for sheet: Sheet) -> some View {
        switch sheet {
        case .compose:
            ComposeView()
        case .settings:
            SettingsSheet()
        }
    }
}

// 3. Navigate from anywhere in your app
struct HomeView: View {
    @Environment(SimpleRouter<Destination, Sheet>.self) private var router
    
    var body: some View {
        VStack {
            Button("Go to Detail") {
                router.navigateTo(.detail(id: "123"))
            }
            
            Button("Show Compose Sheet") {
                router.presentSheet(.compose)
            }
        }
    }
}
```

### Option 2: Tab-Based Navigation

For apps that use TabView with independent navigation stacks per tab.

#### 1. Define Your Tab Type

```swift
import AppRouter

enum AppTab: String, TabType, CaseIterable {
    case home, profile, settings
    
    var id: String { rawValue }
    
    var icon: String {
        switch self {
        case .home: return "house"
        case .profile: return "person"  
        case .settings: return "gear"
        }
    }
}
```

#### 2. Define Destination and Sheet Types

```swift
enum Destination: DestinationType {
    case detail(id: String)
    case list
    case profile(userId: String)
}

enum Sheet: SheetType {
    case settings
    case profile
    case compose
    
    var id: Int { hashValue }
}
```

#### 3. Use the Tab Router

```swift
import SwiftUI
import AppRouter

struct ContentView: View {
    @State private var router = Router<AppTab, Destination, Sheet>(initialTab: .home)
    
    var body: some View {
        TabView(selection: $router.selectedTab) {
            ForEach(AppTab.allCases) { tab in
                NavigationStack(path: $router[tab]) {
                    HomeView()
                        .navigationDestination(for: Destination.self) { destination in
                            destinationView(for: destination)
                        }
                }
                .tabItem {
                    Label(tab.rawValue.capitalized, systemImage: tab.icon)
                }
                .tag(tab)
            }
        }
        .sheet(item: $router.presentedSheet) { sheet in
            sheetView(for: sheet)
        }
    }
    
    @ViewBuilder
    private func destinationView(for destination: Destination) -> some View {
        switch destination {
        case .detail(let id):
            DetailView(id: id)
        case .list:
            ListView()
        case .profile(let userId):
            ProfileView(userId: userId)
        }
    }
    
    @ViewBuilder  
    private func sheetView(for sheet: Sheet) -> some View {
        switch sheet {
        case .settings:
            SettingsView()
        case .profile:
            ProfileSheet()
        case .compose:
            ComposeView()
        }
    }
}
```

## API Reference

### SimpleRouter

For single NavigationStack apps:

```swift
@Observable @MainActor
public final class SimpleRouter<Destination: DestinationType, Sheet: SheetType>
```

#### Properties
- `path: [Destination]` - Navigation path
- `presentedSheet: Sheet?` - Currently presented sheet

#### Methods
- `navigateTo(_:)` - Navigate to a destination
- `popNavigation()` - Pop last destination from stack
- `popToRoot()` - Clear navigation stack
- `presentSheet(_:)` - Present a sheet
- `dismissSheet()` - Dismiss current sheet
- `navigate(to:)` - Navigate using a URL or URL string

### Router

For tab-based apps with independent navigation per tab:

```swift
@Observable @MainActor
public final class Router<Tab: TabType, Destination: DestinationType, Sheet: SheetType>
```

#### Properties
- `selectedTab: Tab` - Currently selected tab
- `presentedSheet: Sheet?` - Currently presented sheet
- `selectedTabPath: [Destination]` - Navigation path for current tab

#### Methods
- `navigateTo(_:for:)` - Navigate to a destination  
- `popNavigation(for:)` - Pop last destination from stack
- `popToRoot(for:)` - Clear navigation stack for tab
- `presentSheet(_:)` - Present a sheet
- `dismissSheet()` - Dismiss current sheet
- `navigate(to:)` - Navigate using a URL or URL string

### Protocols

#### DestinationType  
```swift
public protocol DestinationType: Hashable {
    /// Creates a destination from a URL path component with full path context and query parameters
    static func from(path: String, fullPath: [String], parameters: [String: String]) -> Self?
}
```

#### SheetType
```swift
public protocol SheetType: Hashable, Identifiable {}
```

#### TabType
```swift
public protocol TabType: Hashable, CaseIterable, Identifiable, Sendable {
    var icon: String { get }
}
```
*Only needed for tab-based navigation*

## URL Deep Linking

AppRouter supports URL-based deep linking, allowing you to navigate to specific screens in your app using URLs. This works with both `Router` and `SimpleRouter`.

### Setting Up Deep Linking

#### 1. Implement URL Parsing in Your Destination Type

```swift
enum Destination: DestinationType {
    case detail(id: String)
    case list
    case profile(userId: String)
    case userDetail(id: String)     // Different from generic detail
    case postDetail(id: String)     // Different from generic detail
    
    // Required for URL deep linking with contextual routing support
    static func from(path: String, fullPath: [String], parameters: [String: String]) -> Destination? {
        // Find current position in the path for context
        guard let currentIndex = fullPath.firstIndex(of: path) else {
            return nil
        }
        
        let previousComponent = currentIndex > 0 ? fullPath[currentIndex - 1] : nil
        
        switch (previousComponent, path) {
        // Contextual routing - same path component, different destinations
        case ("users", "detail"):
            let id = parameters["id"] ?? "unknown"
            return .userDetail(id: id)
        case ("posts", "detail"):
            let id = parameters["id"] ?? "unknown"
            return .postDetail(id: id)
        // Standard routing
        case (_, "detail"):
            let id = parameters["id"] ?? "default"
            return .detail(id: id)
        case (_, "list"):
            return .list
        case (_, "profile"):
            let userId = parameters["userId"] ?? "unknown"
            return .profile(userId: userId)
        case (nil, "users"), (nil, "posts"):
            return nil // These are path segments, not destinations
        default:
            return nil
        }
    }
}
```

#### 2. Handle Incoming URLs with SwiftUI's .openURL

```swift
struct ContentView: View {
    @State private var router = SimpleRouter<Destination, Sheet>()
    
    var body: some View {
        NavigationStack(path: $router.path) {
            HomeView()
                .navigationDestination(for: Destination.self) { destination in
                    destinationView(for: destination)
                }
        }
        .environment(router)
        .onOpenURL { url in
            // Handle deep links
            router.navigate(to: url)
        }
    }
}
```

#### 3. Configure Your App's URL Scheme

Add your URL scheme to your app's `Info.plist`:

```xml
<key>CFBundleURLTypes</key>
<array>
    <dict>
        <key>CFBundleURLName</key>
        <string>myapp.deeplink</string>
        <key>CFBundleURLSchemes</key>
        <array>
            <string>myapp</string>
        </array>
    </dict>
</array>
```

### URL Format

URLs follow this format: `scheme://destination1/destination2?param1=value1&param2=value2`

#### Examples

```swift
// Navigate to a single destination
"myapp://list"

// Navigate to a destination with parameters
"myapp://detail?id=123"

// Navigate through multiple destinations (navigation stack)
"myapp://list/detail?id=456"

// Contextual routing - same path, different destinations
"myapp://users/detail?id=user123"  // → userDetail(id: "user123")
"myapp://posts/detail?id=post456"  // → postDetail(id: "post456")
"myapp://detail?id=generic789"     // → detail(id: "generic789")

// Complex navigation with context
"myapp://list/users/detail?id=john&tab=profile"
```

### Contextual Routing

AppRouter supports **contextual routing** where the same path component can create different destinations based on the preceding path. This mirrors web routing patterns where `/users/detail` and `/posts/detail` are different routes.

```swift
// Different destinations from the same "detail" path:
"myapp://users/detail?id=123"  // Creates userDetail(id: "123")
"myapp://posts/detail?id=456"  // Creates postDetail(id: "456") 
"myapp://detail?id=789"        // Creates detail(id: "789")
```

This enables more natural URL structures that match REST API patterns and web conventions.

### Using Deep Links Programmatically

#### Create URLs for Sharing

```swift
// Using the URL helper extension
let url = URL.deepLink(
    scheme: "myapp",
    destinations: [Destination.detail(id: "123")],
    parameters: ["source": "share"]
)

// Share the URL
if let url = url {
    let activityVC = UIActivityViewController(activityItems: [url], applicationActivities: nil)
    // Present activity controller
}
```

#### Navigate Programmatically

```swift
struct HomeView: View {
    @Environment(SimpleRouter<Destination, Sheet>.self) private var router
    
    var body: some View {
        VStack {
            Button("Deep Link to Detail") {
                router.navigate(to: "myapp://detail?id=456")
            }
            
            Button("Navigate with URL") {
                let url = URL(string: "myapp://list/detail?id=789")!
                router.navigate(to: url)
            }
        }
    }
}
```

### Tab-Based Apps

For tab-based apps using `Router`, deep links navigate to the **currently selected tab**:

```swift
struct TabContentView: View {
    @State private var router = Router<AppTab, Destination, Sheet>(initialTab: .home)
    
    var body: some View {
        TabView(selection: $router.selectedTab) {
            // ... tab content
        }
        .onOpenURL { url in
            // This will navigate in the currently active tab
            router.navigate(to: url)
        }
    }
}
```

### Advanced URL Handling

#### Custom URL Processing

```swift
// Handle URLs manually for custom logic
@Environment(AppRouter.self) private var router

func handleCustomURL(_ url: URL) {
    // Add custom pre-processing
    guard url.scheme == "myapp" else { return }
    
    // Log analytics
    Analytics.track("deep_link_opened", parameters: ["url": url.absoluteString])
    
    // Navigate using the router
    let success = router.navigate(to: url)
    
    if !success {
        // Handle failed navigation
        showErrorAlert("Invalid deep link")
    }
}
```

#### URL Validation

```swift
extension Destination {
    static func from(path: String, fullPath: [String], parameters: [String: String]) -> Destination? {
        guard let currentIndex = fullPath.firstIndex(of: path) else {
            return nil
        }
        
        let previousComponent = currentIndex > 0 ? fullPath[currentIndex - 1] : nil
        
        switch (previousComponent, path) {
        case ("users", "detail"):
            // Validate required parameters for user detail
            guard let id = parameters["id"], !id.isEmpty else {
                return nil
            }
            return .userDetail(id: id)
        case (_, "profile"):
            guard let userId = parameters["userId"], 
                  userId.count >= 3 else {
                return nil
            }
            return .profile(userId: userId)
        default:
            return nil
        }
    }
}
```

### Testing Deep Links

#### iOS Simulator
```bash
# Open deep link in simulator
xcrun simctl openurl booted "myapp://detail?id=123"

# Test contextual routing
xcrun simctl openurl booted "myapp://users/detail?id=user123"
xcrun simctl openurl booted "myapp://posts/detail?id=post456"
```

#### Xcode Debugging
1. Edit your scheme
2. Go to "Run" → "Arguments" → "Arguments Passed On Launch"
3. Add: `-FIRDebugEnabled`
4. Go to "Options" → "URL Arguments"
5. Add your test URL: `myapp://detail?id=test`

## Examples

### Type Aliases for Cleaner Syntax

To avoid verbose generic syntax throughout your app, create a type alias:

```swift
// Define once in your app
typealias AppRouter = Router<AppTab, Destination, Sheet>
typealias AppSimpleRouter = SimpleRouter<Destination, Sheet>

// Then use the cleaner syntax everywhere
@Environment(AppRouter.self) private var router
@State private var router = AppRouter(initialTab: .home)
```

### Navigate Programmatically

```swift
struct HomeView: View {
    @Environment(AppRouter.self) private var router
    
    var body: some View {
        VStack {
            Button("Go to Detail") {
                router.navigateTo(.detail(id: "123"))
            }
            
            Button("Show Settings") {
                router.presentSheet(.settings)
            }
            
            Button("Go to Profile Tab") {
                router.selectedTab = .profile
                router.navigateTo(.profile(userId: "user123"), for: .profile)
            }
        }
    }
}
```

### Environment Integration

```swift
struct App: View {
    @State private var router = Router<AppTab, Destination, Sheet>(initialTab: .home)
    
    var body: some View {
        ContentView()
            .environment(router)
            .environment(\.currentTab, router.selectedTab)
    }
}
```

## Requirements

- iOS 17.0+
- macOS 14.0+
- tvOS 17.0+  
- watchOS 10.0+
- Swift 5.9+

## License

MIT License - see LICENSE file for details
